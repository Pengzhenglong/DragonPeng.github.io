

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DragonPeng">
  <meta name="keywords" content="">
  
  <title>React面试题总结 - DragonPeng的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DragonPeng' blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="React面试题总结">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-10 20:15" pubdate>
        January 10, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.7k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      135
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">React面试题总结</h1>
            
            <div class="markdown-body">
              <p>总结了最近的一些面试题和之前的知识点(4.26)</p>
<hr>
<h2 id="较重要（加强）"><a href="#较重要（加强）" class="headerlink" title="较重要（加强）"></a>较重要（加强）</h2><h3 id="一、组件基础"><a href="#一、组件基础" class="headerlink" title="一、组件基础"></a>一、组件基础</h3><h4 id="1-React-事件机制"><a href="#1-React-事件机制" class="headerlink" title="1. React 事件机制"></a>1. React 事件机制</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">div</span> onClick=&#123;<span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>
<p>React并不是将click事件绑定到了div的真实DOM上，而是在document处监听了所有的事件，当事件发生并且冒泡到document处的时候，<strong>React将事件内容封装并交由真正的处理函数运行。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</strong></p>
<p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用event.preventDefault()方法，而不是调用event.stopProppagation()方法。<br><img src="/imageO/react10.png" srcset="/img/loading.gif" lazyload alt="冒泡捕获"></p>
<p>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</p>
<p>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。</p>
<p>实现合成事件的目的如下：<br>●合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；<br>●对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</p>
<h4 id="2-React的事件和普通的HTML事件有什么不同？"><a href="#2-React的事件和普通的HTML事件有什么不同？" class="headerlink" title="2. React的事件和普通的HTML事件有什么不同？"></a>2. React的事件和普通的HTML事件有什么不同？</h4><p>区别：<br>●对于事件名称命名方式，原生事件为全小写，react 事件采用小驼峰；<br>●对于事件函数处理语法，原生事件为字符串，react 事件为函数；<br>●react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。</p>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：<br>●兼容所有浏览器，更好的跨平台；<br>●将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。<br>●方便 react 统一管理和事务机制。</p>
<p>事件的执行顺序为原生事件先执行，合成事件后执行，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</p>
<h4 id="3-React-组件中怎么做事件代理？它的原理是什么？"><a href="#3-React-组件中怎么做事件代理？它的原理是什么？" class="headerlink" title="3. React 组件中怎么做事件代理？它的原理是什么？"></a>3. React 组件中怎么做事件代理？它的原理是什么？</h4><p>React基于Virtual DOM实现了一个SyntheticEvent层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。</p>
<p>在React底层，主要对合成事件做了两件事：<br>●事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。<br>●自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。</p>
<h4 id="4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代"><a href="#4-React-高阶组件、Render-props、hooks-有什么区别，为什么要不断迭代" class="headerlink" title="4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代"></a>4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代</h4><p>这三者是目前react解决代码复用的主要方式：<br>●高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。<br>●render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。<br>●通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。</p>
<h5 id="（1）HOC"><a href="#（1）HOC" class="headerlink" title="（1）HOC"></a>（1）HOC</h5><p>官方解释∶ </p>
<blockquote>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。<br>简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// hoc的定义</span><br>function withSubscription(<span class="hljs-type">WrappedComponent</span>, selectData) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    constructor(props) &#123;<br>      <span class="hljs-keyword">super</span>(props);<br>      <span class="hljs-keyword">this</span>.state = &#123;<br>        data: selectData(<span class="hljs-type">DataSource</span>, props)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 一些通用的逻辑处理</span><br>    render() &#123;<br>      <span class="hljs-comment">// ... 并使用新数据渲染被包装的组件!</span><br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrappedComponent</span> data=&#123;<span class="hljs-keyword">this</span>.state.data&#125; &#123;...<span class="hljs-keyword">this</span>.props&#125; /&gt;;<br>    &#125;<br>  &#125;;<br><br><span class="hljs-comment">// 使用</span><br>const <span class="hljs-type">BlogPostWithSubscription</span> = withSubscription(<span class="hljs-type">BlogPost</span>,<br>  (<span class="hljs-type">DataSource</span>, props) =&gt; <span class="hljs-type">DataSource</span>.getBlogPost(props.id));<br></code></pre></td></tr></table></figure>
<h5 id="（2）Render-props"><a href="#（2）Render-props" class="headerlink" title="（2）Render props"></a>（2）Render props</h5><p>官方解释∶</p>
<blockquote>
<p>“render prop”是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术<br>具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，”render”的命名可以是任何其他有效的标识符。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// DataProvider组件内部的渲染逻辑如下</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Components</span> </span>&#123;<br>     state = &#123;<br>    name: <span class="hljs-symbol">&#x27;To</span>m&#x27;<br>  &#125;<br><br>    render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>          &lt;p&gt;共享数据组件自己内部的渲染逻辑&lt;/p&gt;<br>          &#123; <span class="hljs-keyword">this</span>.props.render(<span class="hljs-keyword">this</span>.state) &#125;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用方式</span><br>&lt;<span class="hljs-type">DataProvider</span> render=&#123;data =&gt; (<br>  &lt;h1&gt;<span class="hljs-type">Hello</span> &#123;data.name&#125;&lt;/h1&gt;<br>)&#125;/&gt;<br></code></pre></td></tr></table></figure>
<p>由此可以看到，render props的优缺点也很明显∶<br>●优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。<br>●缺点：无法在 return 语句外访问数据、嵌套写法不够优雅</p>
<h5 id="（3）Hooks"><a href="#（3）Hooks" class="headerlink" title="（3）Hooks"></a>（3）Hooks</h5><p>官方解释∶</p>
<blockquote>
<p>Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 自定义一个获取订阅数据的hook</span><br>function useSubscription() &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">data</span> = DataSource.getComments();<br>  <span class="hljs-keyword">return</span> [<span class="hljs-keyword">data</span>];<br>&#125;<br><span class="hljs-comment">// </span><br>function CommentList(props) &#123;<br>  <span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">data</span>&#125; = props;<br>  <span class="hljs-keyword">const</span> [subData] = useSubscription();<br>    ...<br>&#125;<br><span class="hljs-comment">// 使用</span><br>&lt;CommentList <span class="hljs-keyword">data</span>=<span class="hljs-string">&#x27;hello&#x27;</span> /&gt;<br></code></pre></td></tr></table></figure>
<p>以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶<br>●使用直观；<br>●解决hoc的prop 重名问题；<br>●解决render props 因共享数据 而出现嵌套地狱的问题；<br>●能在return之外使用数据的问题。</p>
<p>需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。</p>
<h5 id="总结∶"><a href="#总结∶" class="headerlink" title="总结∶"></a>总结∶</h5><p>Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。</p>
<h4 id="6-React-Component-和-React-PureComponent-的区别"><a href="#6-React-Component-和-React-PureComponent-的区别" class="headerlink" title="6. React.Component 和 React.PureComponent 的区别"></a>6. React.Component 和 React.PureComponent 的区别</h4><p>PureComponent表示一个纯组件，可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。</p>
<p>在React中，当prop或者state发生变化时，可以通过在shouldComponentUpdate生命周期函数中执行return false来阻止页面的更新，从而减少不必要的render执行。React.PureComponent会自动执行 shouldComponentUpdate。</p>
<p>不过，pureComponent中的 shouldComponentUpdate() 进行的是浅比较，也就是说如果是引用数据类型的数据，只会比较不是同一个地址，而不会比较这个地址里面的数据是否一致。浅比较会忽略属性和或状态突变情况，其实也就是数据引用指针没有变化，而数据发生改变的时候render是不会执行的。如果需要重新渲染那么就需要重新开辟空间引用数据。PureComponent一般会用在一些纯展示组件上。</p>
<p>使用pureComponent的好处：当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。这是因为react自动做了一层浅比较。</p>
<h4 id="7-Component-Element-Instance-之间有什么区别和联系？"><a href="#7-Component-Element-Instance-之间有什么区别和联系？" class="headerlink" title="7. Component, Element, Instance 之间有什么区别和联系？"></a>7. Component, Element, Instance 之间有什么区别和联系？</h4><p>●元素：一个元素element是一个普通对象(plain object)，描述了对于一个DOM节点或者其他组件component，你想让它在屏幕上呈现成什么样子。元素element可以在它的属性props中包含其他元素(译注:用于形成元素树)。创建一个React元素element成本很低。元素element创建之后是不可变的。<br>●组件：一个组件component可以通过多种方式声明。可以是带有一个render()方法的类，简单点也可以定义为一个函数。这两种情况下，它都把属性props作为输入，把返回的一棵元素树作为输出。<br>●实例：一个实例instance是你在所写的组件类component class中使用关键字this所指向的东西(译注:组件实例)。它用来存储本地状态和响应生命周期事件很有用。</p>
<p>函数式组件(Functional component)根本没有实例instance。类组件(Class component)有实例instance，但是永远也不需要直接创建一个组件的实例，因为React帮我们做了这些。</p>
<h4 id="8-React-createClass和extends-Component的区别有哪些？"><a href="#8-React-createClass和extends-Component的区别有哪些？" class="headerlink" title="8. React.createClass和extends Component的区别有哪些？"></a>8. React.createClass和extends Component的区别有哪些？</h4><p>React.createClass和extends Component的bai区别主要在于：<br>（1）语法区别<br>●createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。<br>●createClass方式的方法定义使用逗号，隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。</p>
<p>（2）propType 和 getDefaultProps<br>●React.createClass：通过proTypes对象和getDefaultProps()方法来设置和获取props.<br>●React.Component：通过设置两个属性propTypes和defaultProps</p>
<p>（3）状态的区别<br>●React.createClass：通过getInitialState()方法返回一个包含初始值的对象<br>●React.Component：通过constructor设置初始状态</p>
<p>（4）this区别<br>●React.createClass：会正确绑定this<br>●React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。</p>
<p>（5）Mixins<br>●React.createClass：使用 React.createClass 的话，可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。<br>●如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。</p>
<h4 id="11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？"><a href="#11-哪些方法会触发-React-重新渲染？重新渲染-render-会做些什么？" class="headerlink" title="11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？"></a>11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</h4><p><strong>（1）哪些方法会触发 react 重新渲染?</strong><br><strong>●setState（）方法被调用</strong><br>setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。<strong>当 setState 传入 null 时，并不会触发 render。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;;<br><br>  render() &#123;<br>    console.log(<span class="hljs-string">&quot;render&quot;</span>);<br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>        &lt;p&gt;&#123;<span class="hljs-keyword">this</span>.state.a&#125;&lt;/p&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            <span class="hljs-keyword">this</span>.setState(&#123; a: <span class="hljs-number">1</span> &#125;); <span class="hljs-comment">// 这里并没有改变 a 的值</span><br>          &#125;&#125;<br>        &gt;<br>          <span class="hljs-type">Click</span> me<br>        &lt;/button&gt;<br>        &lt;button onClick=&#123;() =&gt; <span class="hljs-keyword">this</span>.setState(<span class="hljs-literal">null</span>)&#125;&gt;setState <span class="hljs-literal">null</span>&lt;/button&gt;<br>        &lt;<span class="hljs-type">Child</span> /&gt;<br>      &lt;/<span class="hljs-type">React</span>.<span class="hljs-type">Fragement</span>&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>●父组件重新渲染</strong><br>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p>
<p><strong>（2）重新渲染 render 会做些什么?</strong><br>●会对新旧 VNode 进行对比，也就是我们所说的Diff算法。<br>●对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面<br>●遍历差异对象，根据差异的类型，根据对应对规则更新VNode</p>
<p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p>
<h4 id="13-React声明组件有哪几种方法，有什么不同？"><a href="#13-React声明组件有哪几种方法，有什么不同？" class="headerlink" title="13. React声明组件有哪几种方法，有什么不同？"></a>13. React声明组件有哪几种方法，有什么不同？</h4><p>React 声明组件的三种方式：<br>●函数式定义的无状态组件<br>●ES5原生方式React.createClass定义的组件<br>●ES6形式的extends React.Component定义的组件</p>
<p><strong>（1）无状态函数式组件</strong><br>它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作<br>组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法</p>
<p><strong>（2）ES5 原生方式 React.createClass // RFC</strong><br>React.createClass会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。</p>
<p><strong>（3）E6继承形式 React.Component // RCC</strong><br>目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。</p>
<p>无状态组件相对于于后者的区别：<br>与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。</p>
<p>React.createClass与React.Component区别：<br>① 函数this自绑定<br>●React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。<br>●React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。<br>② 组件属性类型propTypes及其默认props属性defaultProps配置不同<br>●React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的<br>●React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。<br>③ 组件初始状态state的配置不同<br>●React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；<br>●React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。</p>
<h4 id="14-对有状态组件和无状态组件的理解及使用场景"><a href="#14-对有状态组件和无状态组件的理解及使用场景" class="headerlink" title="14. 对有状态组件和无状态组件的理解及使用场景"></a>14. 对有状态组件和无状态组件的理解及使用场景</h4><p>**（1）有状态组件 **<br><strong>特点：</strong><br>●是类组件<br>●有继承<br>●可以使用this<br>●可以使用react的生命周期<br>●使用较多，容易频繁触发生命周期钩子函数，影响性能<br>●内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。</p>
<p><strong>使用场景：</strong><br>●需要使用到状态的。<br>●需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）</p>
<p><strong>总结：</strong><br>类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。</p>
<p><strong>（2）无状态组件</strong><br>特点：<br>●不依赖自身的状态state<br>●可以是类组件或者函数组件。<br>●可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）<br>●有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件<br>●组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。</p>
<p><strong>使用场景：</strong><br>●组件不需要管理 state，纯展示 </p>
<p><strong>优点：</strong><br>●简化代码、专注于 render<br>●组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用<br>●视图和数据的解耦分离</p>
<p><strong>缺点：</strong><br>●无法使用 ref<br>●无生命周期方法<br>●无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染</p>
<p>总结：<br>组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 <code>&lt;Button/&gt;、 &lt;Input /&gt; </code>等组件。</p>
<h4 id="15-对React中Fragment的理解，它的使用场景是什么？"><a href="#15-对React中Fragment的理解，它的使用场景是什么？" class="headerlink" title="15. 对React中Fragment的理解，它的使用场景是什么？"></a>15. 对React中Fragment的理解，它的使用场景是什么？</h4><p>在React中，组件返回的元素只能有一个根元素。为了不添加多余的DOM节点，我们可以使用Fragment标签来包裹所有的元素，Fragment标签不会渲染出任何元素。React官方对Fragment的解释：</p>
<blockquote>
<p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React, &#123; Component, Fragment &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-comment">// 一般形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;React.Fragment&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/React.Fragment&gt;<br>  );<br>&#125;<br><span class="hljs-comment">// 也可以写成以下形式</span><br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;ChildA /&gt;<br>      &lt;ChildB /&gt;<br>      &lt;ChildC /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="16-React如何获取组件对应的DOM元素？"><a href="#16-React如何获取组件对应的DOM元素？" class="headerlink" title="16. React如何获取组件对应的DOM元素？"></a>16. React如何获取组件对应的DOM元素？</h4><p>可以用ref来获取某个子节点的实例，然后通过当前class组件实例的一些特定属性来直接获取子节点实例。ref有三种实现方法:<br>●<strong>字符串格式</strong>：字符串格式，这是React16版本之前用得最多的，例如：<code>&lt;p ref=&quot;info&quot;&gt;span&lt;/p&gt;</code><br>●<strong>函数格式</strong>：ref对应一个方法，该方法有一个参数，也就是对应的节点实例，例如：<code>&lt;p ref=&#123;ele =&gt; this.info = ele&#125;&gt;&lt;/p&gt;</code><br>●<strong>createRef方法</strong>：React 16提供的一个API，使用React.createRef()来实现 　</p>
<h4 id="17-React中可以在render访问refs吗？为什么？"><a href="#17-React中可以在render访问refs吗？为什么？" class="headerlink" title="17. React中可以在render访问refs吗？为什么？"></a>17. React中可以在render访问refs吗？为什么？</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">ref</span>=</span></span><span class="hljs-template-variable">&#123;this.spanRef&#125;</span><span class="xml"><span class="hljs-tag">&gt;</span></span><span class="hljs-template-variable">&#123;this.state.title&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">     this.spanRef.current ? &#x27;有值&#x27; : &#x27;无值&#x27;</span><br><span class="hljs-template-variable">  &#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/&gt;</span></span><br></code></pre></td></tr></table></figure>
<p><strong>不可以，render 阶段 DOM 还没有生成，无法获取 DOM</strong>。DOM 的获取需要在 pre-commit 阶段和 commit 阶段：<br><img src="/imageO/react11s.png" srcset="/img/loading.gif" lazyload alt="生命周期"></p>
<h4 id="18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景"><a href="#18-对React的插槽-Portals-的理解，如何使用，有哪些使用场景" class="headerlink" title="18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景"></a>18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景</h4><p>React 官方对 Portals 的定义：</p>
<blockquote>
<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案<br>Portals 是React 16提供的官方解决方案，使得组件可以脱离父组件层级挂载在DOM树的任何位置。通俗来讲，就是我们 render 一个组件，但这个组件的 DOM 结构并不在本组件内。</p>
</blockquote>
<p>Portals语法如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReactDOM</span>.</span></span>create<span class="hljs-constructor">Portal(<span class="hljs-params">child</span>, <span class="hljs-params">container</span>)</span>;<br></code></pre></td></tr></table></figure>
<p>●第一个参数 child 是可渲染的 React 子项，比如元素，字符串或者片段等;<br>●第二个参数 container 是一个 DOM 元素。</p>
<p>一般情况下，组件的render函数返回的元素会被挂载在它的父级组件上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// DemoComponent元素会被挂载在id为parent的div的元素上</span><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div id=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>        &lt;DemoComponent /&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然而，有些元素需要被挂载在更高层级的位置。最典型的应用场景：当父组件具有overflow: hidden或者z-index的样式设置时，组件有可能被其他元素遮挡，这时就可以考虑要不要使用Portal使组件的挂载脱离父组件。例如：对话框，模态窗。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> DemoComponent <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./DemoComponent&#x27;</span>;<br><span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// react会将DemoComponent组件直接挂载在真实的 dom 节点 domNode 上，生命周期还和16版本之前相同。</span><br>  <span class="hljs-keyword">return</span> ReactDOM.createPortal(<br>    &lt;DemoComponent /&gt;,<br>    domNode,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="19-在React中如何避免不必要的render？"><a href="#19-在React中如何避免不必要的render？" class="headerlink" title="19. 在React中如何避免不必要的render？"></a>19. 在React中如何避免不必要的render？</h4><p>React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：<br><strong>●shouldComponentUpdate 和 PureComponent</strong><br>在 React 类组件中，可以利用 shouldComponentUpdate或者 PureComponent 来减少因父组件更新而触发子组件的 render，从而达到目的。shouldComponentUpdate 来决定是否组件是否重新渲染，如果不希望组件重新渲染，返回 false 即可。<br><strong>●利用高阶组件</strong><br>在函数组件中，并没有 shouldComponentUpdate 这个生命周期，可以利用高阶组件，封装一个类似 PureComponet 的功能<br><strong>●使用 React.memo</strong><br>React.memo 是 React 16.6 新的一个 API，用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 PureComponent 十分类似，但不同的是， React.memo只能用于函数组件。</p>
<h4 id="21-对-React-context-的理解"><a href="#21-对-React-context-的理解" class="headerlink" title="21. 对 React context 的理解"></a>21. 对 React context 的理解</h4><p>在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。</p>
<p>Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
<p>可以把context当做是特定一个组件树内共享的store，用来做数据传递。<strong>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</strong></p>
<p>JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。</p>
<p>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。</p>
<h4 id="22-为什么React并不推荐优先考虑使用Context？"><a href="#22-为什么React并不推荐优先考虑使用Context？" class="headerlink" title="22. 为什么React并不推荐优先考虑使用Context？"></a>22. 为什么React并不推荐优先考虑使用Context？</h4><p>●Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。<br>●尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context<br>●对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。<br>●context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注</p>
<h4 id="23-React中什么是受控组件和非控组件？"><a href="#23-React中什么是受控组件和非控组件？" class="headerlink" title="23. React中什么是受控组件和非控组件？"></a>23. React中什么是受控组件和非控组件？</h4><p>（1）受控组件<br>在使用表单来收集用户输入时，例如<code>&lt;input&gt;&lt;select&gt;&lt;textearea&gt;</code>等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为受控组件，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。</p>
<p>受控组件更新state的流程：<br>●可以通过初始state中设置表单的默认值<br>●每当表单的值发生变化时，调用onChange事件处理器<br>●事件处理器通过事件对象e拿到改变后的状态，并更新组件的state<br>●一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新</p>
<p><strong>受控组件缺陷：</strong><br>表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。</p>
<p>（2）非受控组件<br>如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。</p>
<p>React官方的解释：</p>
<blockquote>
<p>要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。</p>
</blockquote>
<blockquote>
<p>因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。</p>
</blockquote>
<p>例如，下面的代码在非受控组件中接收单个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.handleSubmit = <span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">event</span>)</span> &#123;<br>    alert(<span class="hljs-string">&#x27;A name was submitted: &#x27;</span> + <span class="hljs-built_in">this</span>.input.value);<br>    event.preventDefault();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;form onSubmit=&#123;<span class="hljs-built_in">this</span>.handleSubmit&#125;&gt;<br>        &lt;label&gt;<br>          Name:<br>          &lt;input type=<span class="hljs-string">&quot;text&quot;</span> ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> <span class="hljs-built_in">this</span>.input = input&#125; /&gt;<br>        &lt;/label&gt;<br>        &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Submit&quot;</span> /&gt;<br>      &lt;/form&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结：页面中所有输入类的DOM如果是现用现取的称为非受控组件，而通过setState将输入的值维护到了state中，需要时再从state中取出，这里的数据就受到了state的控制，称为受控组件。</p>
<h4 id="24-React中refs的作用是什么？有哪些应用场景？"><a href="#24-React中refs的作用是什么？有哪些应用场景？" class="headerlink" title="24. React中refs的作用是什么？有哪些应用场景？"></a>24. React中refs的作用是什么？有哪些应用场景？</h4><p>Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：<br>●处理焦点、文本选择或者媒体的控制<br>●触发必要的动画<br>●集成第三方 DOM 库</p>
<p>Refs 是使用 React.createRef() 方法创建的，他通过 ref 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 ref 在构造函数中分配给其实例属性：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>    <span class="hljs-keyword">this</span>.myRef = <span class="hljs-type">React</span>.createRef()<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;div ref=&#123;<span class="hljs-keyword">this</span>.myRef&#125; /&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于函数组件没有实例，因此不能在函数组件上直接使用 ref：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scala">function <span class="hljs-type">MyFunctionalComponent</span>() &#123;<br>  <span class="hljs-keyword">return</span> &lt;input /&gt;;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.textInput = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// 这将不会工作！</span><br>    <span class="hljs-keyword">return</span> (<br>      &lt;<span class="hljs-type">MyFunctionalComponent</span> ref=&#123;<span class="hljs-keyword">this</span>.textInput&#125; /&gt;<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但可以通过闭合的帮助在函数组件内部进行使用 Refs：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里必须声明 textInput，这样 ref 回调才可以引用它</span><br>  <span class="hljs-keyword">let</span> textInput = <span class="hljs-literal">null</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    textInput.focus();<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;text&quot;</span><br>        ref=&#123;<span class="hljs-function">(<span class="hljs-params">input</span>) =&gt;</span> &#123; textInput = input; &#125;&#125; /&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;button&quot;</span><br>        value=<span class="hljs-string">&quot;Focus the text input&quot;</span><br>        onClick=&#123;handleClick&#125;<br>      /&gt;<br>    &lt;/div&gt;<br>  );  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意：<br>●不应该过度的使用 Refs<br>●ref 的返回值取决于节点的类型：<br>○当 ref 属性被用于一个普通的 HTML 元素时，React.createRef() 将接收底层 DOM 元素作为他的 current 属性以创建 ref。<br>○当 ref 属性被用于一个自定义的类组件时，ref 对象将接收该组件已挂载的实例作为他的 current。<br>●当在父组件中需要访问子组件中的 ref 时可使用传递 Refs 或回调 Refs。</p>
<h4 id="25-React中除了在构造函数中绑定this，还有别的方式吗？"><a href="#25-React中除了在构造函数中绑定this，还有别的方式吗？" class="headerlink" title="25. React中除了在构造函数中绑定this，还有别的方式吗？"></a>25. React中除了在构造函数中绑定this，还有别的方式吗？</h4><p>●在构造函数中绑定this</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      super(props); </span></span><br><span class="hljs-function"><span class="hljs-comment">       this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">       &#125;</span></span><br><span class="hljs-function">       <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span> = <span class="hljs-title">this</span>.<span class="hljs-title">getMsg</span>.<span class="hljs-title">bind</span><span class="hljs-params">(this)</span></span><br><span class="hljs-function">   &#125;</span><br></code></pre></td></tr></table></figure>
<p>●函数定义的时候使用箭头函数</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(props)</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">    super(props);</span></span><br><span class="hljs-function"><span class="hljs-comment">    this.state=&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">           msg:&#x27;hello world&#x27;,</span></span><br><span class="hljs-function"><span class="hljs-comment">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-title">render</span><span class="hljs-params">()</span><span class="hljs-comment">&#123;</span></span><br><span class="hljs-function"><span class="hljs-comment">      &lt;button onClcik=&#123;()=&gt;&#123;alert(this.state.msg)&#125;</span>&#125;&gt;点我&lt;/<span class="hljs-title">button</span>&gt;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>
<p>●函数调用是使用bind绑定this</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button onClick=&#123;<span class="hljs-keyword">this</span>.getMsg.bind(<span class="hljs-keyword">this</span>)&#125;&gt;点我&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<h4 id="26-React组件的构造函数有什么作用？它是必须的吗？"><a href="#26-React组件的构造函数有什么作用？它是必须的吗？" class="headerlink" title="26. React组件的构造函数有什么作用？它是必须的吗？"></a>26. React组件的构造函数有什么作用？它是必须的吗？</h4><p>构造函数主要用于两个目的：<br>●通过将对象分配给this.state来初始化本地状态<br>●将事件处理程序方法绑定到实例上<br>所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LikeButton</span> <span class="hljs-title">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>() &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.state = &#123;<br>      liked: <span class="hljs-literal">false</span><br>    &#125;;<br>    <span class="hljs-keyword">this</span>.handleClick = <span class="hljs-keyword">this</span>.handleClick.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br>  handleClick() &#123;<br>    <span class="hljs-keyword">this</span>.setState(&#123;liked: !<span class="hljs-keyword">this</span>.state.liked&#125;);<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">this</span>.state.liked ? <span class="hljs-string">&#x27;liked&#x27;</span> : <span class="hljs-string">&#x27;haven\&#x27;t liked&#x27;</span>;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div onClick=&#123;<span class="hljs-keyword">this</span>.handleClick&#125;&gt;<br>        You &#123;text&#125; <span class="hljs-keyword">this</span>. Click to toggle.<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br>ReactDOM.render(<br>  &lt;LikeButton /&gt;,<br>  document.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>
<p>构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。</p>
<p>注意：<br>●constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用<br>●JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件</p>
<h4 id="27-React-forwardRef是什么？它有什么作用？"><a href="#27-React-forwardRef是什么？它有什么作用？" class="headerlink" title="27. React.forwardRef是什么？它有什么作用？"></a>27. React.forwardRef是什么？它有什么作用？</h4><p>React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：<br>●转发 refs 到 DOM 组件<br>●在高阶组件中转发 refs</p>
<h4 id="28-类组件与函数组件有什么异同？"><a href="#28-类组件与函数组件有什么异同？" class="headerlink" title="28. 类组件与函数组件有什么异同？"></a>28. 类组件与函数组件有什么异同？</h4><p><strong>相同点：</strong><br>组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p>
<p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p>
<p><strong>不同点：</strong><br>●它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。<br>●之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。<br>●性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。<br>●从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。<br>●类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。</p>
<h3 id="二、数据管理"><a href="#二、数据管理" class="headerlink" title="二、数据管理"></a>二、数据管理</h3><h2 id="还未被问到（加强）"><a href="#还未被问到（加强）" class="headerlink" title="还未被问到（加强）"></a>还未被问到（加强）</h2><h2 id="被问到了掌握了以及-较简单"><a href="#被问到了掌握了以及-较简单" class="headerlink" title="被问到了掌握了以及(较简单)"></a>被问到了掌握了以及(较简单)</h2><h2 id="其他待整理-（掘金）"><a href="#其他待整理-（掘金）" class="headerlink" title="其他待整理 （掘金）"></a>其他待整理 （掘金）</h2><h3 id="hooks用过吗？聊聊react中class组件和函数组件的区别"><a href="#hooks用过吗？聊聊react中class组件和函数组件的区别" class="headerlink" title="hooks用过吗？聊聊react中class组件和函数组件的区别"></a>hooks用过吗？聊聊react中class组件和函数组件的区别</h3><p>类组件是使用ES6 的 class 来定义的组件。 函数组件是接收一个单一的 <strong>props</strong> 对象并返回一个React元素。</p>
<p>关于React的两套API（类（class）API 和基于函数的钩子（hooks） API）。官方推荐使用钩子（函数），而不是类。因为钩子更简洁，代码量少，用起来比较”轻”，而类比较”重”。而且，钩子是函数，更符合 React 函数式的本质。</p>
<p>函数一般来说，只应该做一件事，就是返回一个值。 如果你有多个操作，每个操作应该写成一个单独的函数。而且，数据的状态应该与操作方法分离。根据函数这种理念，React 的函数组件只应该做一件事情：返回组件的 HTML 代码，而没有其他的功能。函数的返回结果只依赖于它的参数。不改变函数体外部数据、函数执行过程里面没有副作用。</p>
<p>类（class）是数据和逻辑的封装。 也就是说，组件的状态和操作方法是封装在一起的。如果选择了类的写法，就应该把相关的数据和操作，都写在同一个 class 里面。</p>
<h3 id="类组件的缺点"><a href="#类组件的缺点" class="headerlink" title="类组件的缺点 :"></a>类组件的缺点 :</h3><p>大型组件很难拆分和重构，也很难测试。<br>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。<br>组件类引入了复杂的编程模式，比如 render props 和高阶组件。<br>难以理解的 class，理解 JavaScript 中 this 的工作方式。</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><p>函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。<br>1.状态的有无<br>hooks出现之前，函数组件<strong>没有实例，没有生命周期，没有state，没有this</strong>，所以我们称函数组件为无状态组件。 hooks出现之前，react中的函数组件通常只考虑负责UI的渲染，没有自身的状态没有业务逻辑代码，是一个纯函数。它的输出只由参数props决定，不受其他任何因素影响。</p>
<p>2.调用方式的不同<br>函数组件重新渲染，将重新调用组件方法返回新的react元素。类组件重新渲染将new一个新的组件实例，然后调用render类方法返回react元素，这也说明为什么类组件中this是可变的。</p>
<p>3.因为调用方式不同，在函数组件使用中会出现问题<br>在操作中改变状态值，类组件可以获取最新的状态值，而函数组件则会按照顺序返回状态值</p>
<h3 id="React-Hooks（钩子的作用）"><a href="#React-Hooks（钩子的作用）" class="headerlink" title="React Hooks（钩子的作用）"></a>React Hooks（钩子的作用）</h3><p>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。<br>React Hooks的几个常用钩子:</p>
<ol>
<li>useState() //状态钩子</li>
<li>useContext() //共享状态钩子</li>
<li>useReducer() //action 钩子</li>
<li>useEffect() //副作用钩子</li>
</ol>
<p>还有几个不常见的大概的说下</p>
<p>1.useCallback 记忆函数 一般把<strong>函数式组件理解为class组件render函数的语法糖</strong>，所以每次重新渲染的时候，函数式组件内部所有的代码都会重新执行一遍。而有了 useCallback 就不一样了，你可以通过 useCallback 获得一个记忆后的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> memoizedHandleClick = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Click happened&#x27;</span>)<br>  &#125;, []); <span class="hljs-comment">// 空数组代表无论什么情况下该函数都不会发生改变</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SomeComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;memoizedHandleClick&#125;</span>&gt;</span>Click Me<span class="hljs-tag">&lt;/<span class="hljs-name">SomeComponent</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二个参数传入一个数组，数组中的每一项一旦值或者引用发生改变，useCallback 就会重新返回一个新的记忆函数提供给后面进行渲染。</p>
<p>2.useMemo 记忆组件 useCallback 的功能完全可以由 useMemo 所取代，如果你想通过使用 useMemo 返回一个记忆函数也是完全可以的。 唯一的区别是：<strong>useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。</strong><br>所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</p>
<p>3.useRef 保存引用值<br>useRef 跟 createRef 类似，都可以用来生成对 DOM 对象的引用。useRef 返回的值传递给组件或者 DOM 的 ref 属性，就可以通过 ref.current 值<strong>访问组件或真实的 DOM 节点，重点是组件也是可以访问到的</strong>，从而可以对 DOM 进行一些操作，比如监听事件等等。</p>
<p>4.useImperativeHandle 穿透 Ref<br>通过 useImperativeHandle 用于让父组件获取子组件内的索引</p>
<p>5.useLayoutEffect 同步执行副作用<br>大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行。<br><strong>useEffect和useLayoutEffect有什么区别</strong>：简单来说就是调用时机不同，useLayoutEffect和原来componentDidMount&amp;componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。官方建议优先使用useEffect</p>
<h3 id="setState-既存在异步情况也存在同步情况"><a href="#setState-既存在异步情况也存在同步情况" class="headerlink" title="setState 既存在异步情况也存在同步情况"></a>setState 既存在异步情况也存在同步情况</h3><p>1.异步情况 <strong>在React事件当中是异步操作</strong><br>2.同步情况 如果是在<strong>setTimeout事件或者自定义的dom事件</strong>中，都是同步的</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pf">//<span class="hljs-built_in">set</span>Timeout事件<br>import React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br>class Count extends Component&#123;<br>    constructor(props)&#123;<br>        super(props);<br>        this.<span class="hljs-keyword">state</span> = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    render()&#123;<br>        return (<br>            <span class="hljs-variable">&lt;&gt;</span><br>                <span class="hljs-variable">&lt;p&gt;</span>count:&#123;this.<span class="hljs-keyword">state</span>.count&#125;&lt;/p&gt;<br>                <span class="hljs-variable">&lt;button onClick=&#123;this.btnAction&#125;&gt;</span>增加&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    btnAction = ()=&gt;&#123;<br>        //不能直接修改<span class="hljs-keyword">state</span>，需要通过<span class="hljs-built_in">set</span>State进行修改<br>        //同步<br>        <span class="hljs-built_in">set</span>Timeout(()=&gt;&#123;<br>            this.<span class="hljs-built_in">set</span>State(&#123;<br>                count: this.<span class="hljs-keyword">state</span>.count + <span class="hljs-number">1</span><br>            &#125;);<br>            console.<span class="hljs-keyword">log</span>(this.<span class="hljs-keyword">state</span>.count);<br>        &#125;)<br>    &#125;<br>&#125;<br><br>export <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义dom事件</span><br><span class="hljs-keyword">import</span> React,&#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(props);<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            count:<span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;&gt;<br>                &lt;p&gt;count:&#123;<span class="hljs-built_in">this</span>.state.count&#125;&lt;/p&gt;<br>                &lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;绑定点击事件&lt;/button&gt;<br>            &lt;/&gt;<br>        )<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//自定义dom事件，也是同步修改</span><br>        <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">this</span>.setState(&#123;<br>                count: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>            &#125;);<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.count);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Count;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/imageO/react5.png" srcset="/img/loading.gif" lazyload alt="生命周期"></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">安装<br>当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：<br><br><span class="hljs-function"><span class="hljs-title">constructor</span><span class="hljs-params">()</span></span><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span><span class="hljs-params">()</span></span><br><br>更新中<br>更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：<br><br>static getDerivedStateFromProps()<br><span class="hljs-function"><span class="hljs-title">shouldComponentUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">getSnapshotBeforeUpdate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span><span class="hljs-params">()</span></span><br><br>卸载<br>当组件从 DOM 中移除时调用此方法：<br><br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>
<h3 id="说一下-react-fiber"><a href="#说一下-react-fiber" class="headerlink" title="说一下 react-fiber"></a>说一下 react-fiber</h3><h4 id="1）背景"><a href="#1）背景" class="headerlink" title="1）背景"></a>1）背景</h4><p>react-fiber 产生的根本原因，是<strong>大量的同步计算任务阻塞了浏览器的 UI 渲染</strong>。默认情况下，JS 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系。如果 JS 运算持续占用主线程，页面就没法得到及时的更新。当我们调用setState更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒，就容易出现掉帧的现象。</p>
<h4 id="2）实现原理"><a href="#2）实现原理" class="headerlink" title="2）实现原理"></a>2）实现原理</h4><p>react内部运转分三层：</p>
<ol>
<li>Virtual DOM 层，描述页面长什么样。</li>
<li>Reconciler 层，负责调用组件生命周期方法，进行 Diff 运算等。</li>
<li>Renderer 层，根据不同的平台，渲染出相应的页面，比较常见的是 ReactDOM 和 ReactNative。</li>
</ol>
<p><strong>Fiber 其实指的是一种数据结构，它可以用一个纯 JS 对象来表示：</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const fiber = &#123;<br>    stateNode,    <span class="hljs-regexp">//</span> 节点实例<br>    child,        <span class="hljs-regexp">//</span> 子节点<br>    sibling,      <span class="hljs-regexp">//</span> 兄弟节点<br>    return,       <span class="hljs-regexp">//</span> 父节点<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了实现不卡顿，就需要有一个调度器 (Scheduler) 来进行任务分配。优先级高的任务（如键盘输入）可以打断优先级低的任务（如Diff）的执行，从而更快的生效。任务的优先级有六种：</p>
<ol>
<li>synchronous，与之前的Stack Reconciler操作一样，同步执行</li>
<li>task，在next tick之前执行</li>
<li>animation，下一帧之前执行</li>
<li>high，在不久的将来立即执行</li>
<li>low，稍微延迟执行也没关系</li>
<li>offscreen，下一次render时或scroll时才执行</li>
</ol>
<p>Fiber Reconciler（react ）执行过程分为2个阶段：</p>
<ol>
<li>阶段一，生成 Fiber 树，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断。阶段一可被打断的特性，让优先级更高的任务先执行，从框架层面大大降低了页面掉帧的概率。</li>
<li>阶段二，将需要更新的节点一次过批量更新，这个过程不能被打断。</li>
</ol>
<p>Fiber树：React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 Virtual DOM Tree，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 Fiber Tree。Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p>
<p>从Stack Reconciler到Fiber Reconciler，源码层面其实就是干了一件递归改循环的事情<br>传送门 ☞# <a target="_blank" rel="noopener" href="https://juejin.cn/post/7002250258826657799">深入了解 Fiber</a></p>
<h3 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h3><p>Portals 提供了一种一流的方式来将子组件渲染到存在于父组件的 DOM 层次结构之外的 DOM 节点中。结构不受外界的控制的情况下就可以使用portals进行创建</p>
<h3 id="何时要使用异步组件？如和使用异步组件"><a href="#何时要使用异步组件？如和使用异步组件" class="headerlink" title="何时要使用异步组件？如和使用异步组件"></a>何时要使用异步组件？如和使用异步组件</h3><p>加载大组件的时候<br>路由异步加载的时候</p>
<p>react 中要配合 Suspense 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 异步懒加载</span><br><span class="hljs-keyword">const</span> Box = lazy(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/Box&#x27;</span>));<br><span class="hljs-comment">// 使用组件的时候要用suspense进行包裹</span><br>&lt;Suspense fallback=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;&gt;<br>    &#123;show &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Box</span>/&gt;</span></span>&#125;<br>&lt;/Suspense&gt;<br></code></pre></td></tr></table></figure>
<h3 id="React-事件绑定原理"><a href="#React-事件绑定原理" class="headerlink" title="React 事件绑定原理"></a>React 事件绑定原理</h3><p>React并不是将click事件绑在该div的真实DOM上，而是<strong>在document处监听所有支持的事件</strong>，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。<br>另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 <strong>event.preventDefault</strong>。<br><img src="/imageO/react10.png" srcset="/img/loading.gif" lazyload alt="绑定事件"></p>
<h5 id="转载文章"><a href="#转载文章" class="headerlink" title="转载文章"></a>转载文章</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016593221815910408#heading-83">连八股文都不懂还指望在前端混下去么</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
                    
                      <a class="hover-with-bg" href="/tags/React/">React</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/10/Vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue面试题总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/07/%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <span class="hidden-mobile">计网+HTTP+浏览器+网络安全面试题总结</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
