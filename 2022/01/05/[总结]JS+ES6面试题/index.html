

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DragonPeng">
  <meta name="keywords" content="">
  
  <title>JS+ES6面试题总结 - DragonPeng的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DragonPeng' blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JS+ES6面试题总结">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-05 20:15" pubdate>
        January 5, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      20.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      239
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JS+ES6面试题总结</h1>
            
            <div class="markdown-body">
              <p>总结了最近的一些面试题和之前的知识点</p>
<hr>
<h2 id="进阶-多看"><a href="#进阶-多看" class="headerlink" title="进阶(多看)"></a>进阶(多看)</h2><h3 id="EventLoop-事件循环"><a href="#EventLoop-事件循环" class="headerlink" title="EventLoop 事件循环"></a>EventLoop 事件循环</h3><p>JS是单线程的，为了<strong>防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列</strong>。微任务队列的代表就是，<strong>Promise.then，MutationObserver</strong>，宏任务的话就是 <strong>setImmediate setTimeout setInterval</strong></p>
<ol>
<li><p>首先，整体的<strong>script(作为第一个宏任务)开始执行的时候</strong>，会把<strong>所有代码分为同步任务、异步任务</strong>两部分</p>
</li>
<li><p><strong>同步任务</strong>会直接进入<strong>主线程依次执行</strong>(执行栈)</p>
</li>
<li><p><strong>异步任务</strong>会再分为<strong>宏任务和微任务</strong></p>
</li>
<li><p>宏任务进入到<strong>Event Table中，并在里面注册回调函数</strong>，<strong>每当指定的事件完成时（例如延时器，或者异步请求，dom监听）</strong>，Event Table会将这个函数移到<strong>Event Queue</strong>中</p>
</li>
<li><p><strong>微任务</strong>也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p>
</li>
<li><p>当<strong>主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</strong>（微任务队列清空后，进入宏任务队列，<strong>取队列的第一项任务放入Stack(栈）中执行</strong>，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列）<br>上述过程会<strong>不断重复</strong>（循环），这就是Event Loop，比较完整的事件循环</p>
</li>
</ol>
<p>JS运行的环境。一般为浏览器或者Node。 在浏览器环境中，有<strong>JS 引擎线程和渲染线程，且两个线程互斥</strong>。 Node环境中，只有JS 线程。 不同环境执行机制有差异，不同任务进入不同Event Queue队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<h4 id="当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务-gt-微任务-gt-GUI渲染-gt-宏任务-gt-…）-（也就是当前）"><a href="#当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务-gt-微任务-gt-GUI渲染-gt-宏任务-gt-…）-（也就是当前）" class="headerlink" title="当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; …） （也就是当前）"></a>当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完（宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; …） （也就是当前）</h4><h4 id="你怎么理解执行栈的？"><a href="#你怎么理解执行栈的？" class="headerlink" title="你怎么理解执行栈的？"></a>你怎么理解执行栈的？</h4><h5 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h5><p>JavaScript 中有三种执行上下文类型。</p>
<p><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。<br><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。<br><strong>Eval 函数执行上下文</strong> — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。</p>
<h5 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h5><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO<strong>先进后出</strong>数据结构的栈，被用来存储代码运行时创建的所有执行上下文。<br>当 JavaScript 引擎第一次遇到你的脚本时，它会<strong>创建一个全局的执行上下文并且压入当前执行栈</strong>。每当引擎<strong>遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</strong><br>引擎会执行那些执行<strong>上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903682283143181">掘金</a></p>
<h5 id="怎么创建执行上下文？"><a href="#怎么创建执行上下文？" class="headerlink" title="怎么创建执行上下文？"></a>怎么创建执行上下文？</h5><ol>
<li>this 值的决定，即我们所熟知的 This 绑定。</li>
<li>创建词法环境组件。</li>
<li>创建变量环境组件。</li>
</ol>
<ul>
<li>eventLoop 是由<strong>JS的宿主环境（浏览器）</strong>来实现的；</li>
<li>浏览器中的任务源(task):<ol>
<li>宏任务(macrotask)：<strong>宿主环境提供的</strong>，比如浏览器<strong>ajax、setTimeout、setInterval、setTmmediate(只兼容ie)、script、</strong>2. 2.requestAnimationFrame、messageChannel、<strong>UI渲染</strong>、一些浏览器api</li>
<li>微任务(microtask)：<strong>语言本身提供</strong>的，比如**promise.thenthen、queueMicrotask(基于then)、mutationObserver(浏览器提供)**、messageChannel 、mutationObersve<br><img src="/imageO/20.png" srcset="/img/loading.gif" lazyload alt="如图"></li>
</ol>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/07/03/Js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/">博客：这一次，彻底弄懂 JavaScript 执行机制</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7001881781125251086">传送门 ☞ # 宏任务和微任务</a></p>
<h3 id="promise-原理-（回调函数-状态处理队列）"><a href="#promise-原理-（回调函数-状态处理队列）" class="headerlink" title="promise 原理 （回调函数+状态处理队列）"></a>promise 原理 （回调函数+状态处理队列）</h3><p>promise 的本质是回调函数，then 方法的本质是依赖收集，它把 fulfilled 状态要执行的回调函数放在一个队列， rejected 状态要执行的回调函数放在另一个队列。待 promise 从 pending 变为 fulfilled/rejected 状态后，把相应队列的所有函数，执行一遍。</p>
<h3 id="如何解决异步回调地狱-异步编程的实现方式？"><a href="#如何解决异步回调地狱-异步编程的实现方式？" class="headerlink" title="如何解决异步回调地狱||  异步编程的实现方式？"></a>如何解决异步回调地狱||  异步编程的实现方式？</h3><p>promise、generator、async/await<br>js 中的异步机制可以分为以下几种：</p>
<ol>
<li>第一种最常见的是使用回调函数的方式，使用回调函数的方式有一个缺点是，<strong>多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高</strong>，不利于代码的可维护。</li>
</ol>
<h4 id="2-第二种是-Promise-的方式，使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确"><a href="#2-第二种是-Promise-的方式，使用-Promise-的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个-then-的链式调用，可能会造成代码的语义不够明确" class="headerlink" title="2. 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确"></a>2. 第二种是 Promise 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确</h4><p>从语法上说，<strong>Promise 是一个对象，从它可以获取异步操作的消息。</strong><br>Promise 异步操作有三种状态：<strong>pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</strong><br>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br>语法：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">new <span class="hljs-type">Promise</span>( function(resolve, reject) <span class="hljs-meta">&#123;...&#125;</span>);<br></code></pre></td></tr></table></figure>

<p>状态的缺点：<br><strong>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</strong><br><strong>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部</strong><br>当<strong>处于 pending 状态时，无法得知目前进展到哪一个阶段</strong>（刚刚开始还是即将完成）。</p>
<ol>
<li><p>generator</p>
</li>
<li><p>第四种是使用 async 函数的形式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候， <strong>如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行</strong>。因此我们可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/11/Es6async&await/">博客：</a></p>
</li>
</ol>
<h3 id="promise-generotor-await-await后面接收的是什么"><a href="#promise-generotor-await-await后面接收的是什么" class="headerlink" title="promise  /generotor /await  (await后面接收的是什么)"></a>promise  /generotor /await  (await后面接收的是什么)</h3><h4 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h4><p>then是<strong>实例状态发生改变</strong>时的回调函数，第一个参数是resolved状态的回调函数，第二个参数是rejected状态的回调函数<br>then方法返回的是一个新的Promise实例，也就是promise能链式书写的原因<br>在 <strong>JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</strong></p>
<h5 id="promise-then-返回的新的promise状态与值是怎样决定的？"><a href="#promise-then-返回的新的promise状态与值是怎样决定的？" class="headerlink" title="promise.then 返回的新的promise状态与值是怎样决定的？"></a>promise.then 返回的新的promise状态与值是怎样决定的？</h5><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-number">1</span>)<br>&#125;).<span class="hljs-keyword">then</span>(<br>    value =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;success1&#x27;</span>,value)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span> <span class="hljs-regexp">//</span>默认为<span class="hljs-literal">undefined</span><br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<br>        <span class="hljs-regexp">//</span> <span class="hljs-keyword">throw</span> <span class="hljs-number">4</span><br>    &#125;)<br></code></pre></td></tr></table></figure>

<p>结论：<br>1、通过return 返回一个非promise的值，则新promise的状态fulfilled，值为return 的值<br>2、不做任何处理（不return == return undefined），所以根据结论1新promise的状态为fulfilled，值为undefined<br>3、<strong>通过throw主动抛出错误或者代码出现错误，则promise的状态为rejected，值为throw的值</strong><br>4、通过<strong>return 返回一个promise对象，则新promise就是return的promsie</strong></p>
<ul>
<li>可根据以上代码，挨个取消注释并在控制台打印promise2查看</li>
</ul>
<h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h4><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作<br><a target="_blank" rel="noopener" href="https://vue3js.cn/interview/es6/promise.html#%E4%B8%80%E3%80%81%E4%BB%8B%E7%BB%8D">参考</a><br>正常情况下，async中的<strong>await命令是一个Promise对象，返回该对象的结果。<br>但如果不是Promise对象的话，就会直接返回对应的值，相当于Promise.resolve()<br>如果在async函数中抛出了错误，则终止错误结果，不会继续向下执行。</strong></p>
<h3 id="Promise-all、Promise-race、Promise-allSettled-分别怎么用？"><a href="#Promise-all、Promise-race、Promise-allSettled-分别怎么用？" class="headerlink" title="Promise.all、Promise.race、Promise.allSettled 分别怎么用？"></a>Promise.all、Promise.race、Promise.allSettled 分别怎么用？</h3><h4 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h4><p>简而言之：Promise.all( ).then( )适用于处理多个异步任务，且所有的异步任务都得到结果时的情况。</p>
<blockquote>
<p>promise1和promise2都成功才会调用success1<br>比如：用户点击按钮，会弹出一个弹出对话框，对话框中有两部分数据呈现，这两部分数据分别是不同的后端接口获取的数据。<br>弹框弹出后的初始情况下，就让这个弹出框处于数据加载中的状态，当这两部分数据都从接口获取到的时候，才让这个数据加载中状态消失。让用户看到这两部分的数据。</p>
</blockquote>
<h4 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h4><p>Promise.race赛跑机制，只认第一名</p>
<blockquote>
<p>promise1和promise2只要有一个成功就会调用success1<br>Promise.race其实使用的并不多，如果真要使用。我们可以提出这样一个需求：<br><strong>比如：点击按钮发请求，当后端的接口超过一定时间，假设超过三秒，没有返回结果，我们就提示用户请求超时</strong></p>
</blockquote>
<h4 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h4><p>Promise.allSettled(promises) 允许您并行执行互相独立的promise, 并每一个promise执行之后的状态（已完成或拒绝）存放在数组中。</p>
<p>当您需要执行并行和独立的异步操作并获取到异步操作的所有结果时，Promise.allSettled(…) 非常有用，即使某些异步操作可能会失败。</p>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/17/ES6(promise)/#Promise-all">博客</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6998891444312211492#heading-4">博客</a></p>
<h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><blockquote>
<p>简单来说，作用域 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。</p>
</blockquote>
<p>javascript 中大部分情况下，只有两种作用域类型：</p>
<ol>
<li>全局作用域：全局作用域为程序的最外层作用域，一直存在。</li>
<li>函数作用域：函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。</li>
</ol>
<p>由于作用域的限制，每段独立的执行代码块<strong>只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量</strong>。</p>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>当<strong>可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找…一直找到全局作用域</strong>。我们把这种作用域的嵌套机制，称为 作用域链。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904165672484871#heading-14">面试官：说说作用域和闭包吧</a></p>
<h3 id="闭包是什么？有什么优点和缺点？-（作用域-amp-amp-函数套函数，内部函数对外部函数变量的引用会产生闭包）"><a href="#闭包是什么？有什么优点和缺点？-（作用域-amp-amp-函数套函数，内部函数对外部函数变量的引用会产生闭包）" class="headerlink" title="闭包是什么？有什么优点和缺点？ （作用域&amp;&amp;函数套函数，内部函数对外部函数变量的引用会产生闭包）"></a>闭包是什么？有什么优点和缺点？ （作用域&amp;&amp;函数套函数，内部函数对外部函数变量的引用会产生闭包）</h3><p> 解答：闭包是指有权访问另一个函数作用域中的变量的函数。<br>  优点：① 能够读取函数内部的变量；②让这些变量一直存在于内存中，不会在调用结束后被垃圾回收机制回收；3.对变量进行保护，防止全局污染<br>  缺点：由于闭包会使用函数中的变量存在在内存中，内存消耗很大，所以不能滥用闭包；解决的办法是退出函数之前，将不使用的局部变量删除；<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/26/JS%E9%97%AD%E5%8C%85%E7%90%86%E8%A7%A3/">博客：</a></p>
<h4 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h4><ol>
<li>for循环+setTimeout中i访问的是全局变量，使用闭包保存变量</li>
</ol>
<p>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5<br>2. 防抖节流</p>
<h3 id="防抖-amp-amp-节流"><a href="#防抖-amp-amp-节流" class="headerlink" title="防抖&amp;&amp;节流"></a>防抖&amp;&amp;节流</h3><h4 id="介绍节流防抖原理、区别以及应用"><a href="#介绍节流防抖原理、区别以及应用" class="headerlink" title="介绍节流防抖原理、区别以及应用"></a>介绍节流防抖原理、区别以及应用</h4><h5 id="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行-（-clearTimeout-timeout-）"><a href="#防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如-1-秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待-1-秒，直到能最终执行-（-clearTimeout-timeout-）" class="headerlink" title="防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行 （ clearTimeout(timeout) ）"></a>防抖：多次触发事件，事件处理函数只能执行一次，并且是在触发操作结束时执行。也就是说，当一个事件被触发准备执行事件函数前，会等待一定的时间（这时间是码农自己去定义的，比如 1 秒），如果没有再次被触发，那么就执行，如果被触发了，那就本次作废，重新从新触发的时间开始计算，并再次等待 1 秒，直到能最终执行 （ clearTimeout(timeout) ）</h5><h5 id="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"><a href="#节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次" class="headerlink" title="节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次"></a>节流：事件触发后，规定时间内，事件处理函数不能再次被调用。也就是说在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次</h5><p>函数执行的前提条件是开关打开，持续触发时，持续关闭开关，等到setTimeout到时间了，再把开关打开，函数就会执行了。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>防抖：搜索框搜索输入，并在输入完以后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后，再重新渲染。<br>节流：滚动加载更多、搜索框搜的索联想功能、高频点击、表单重复提交……<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/16/JS&%E9%98%B2%E6%8A%96&%E8%8A%82%E6%B5%81/">函数的防抖与节流 _</a></p>
<h4 id="匿名函数的作用"><a href="#匿名函数的作用" class="headerlink" title="匿名函数的作用"></a>匿名函数的作用</h4><p>1、通过匿名函数可以实现闭包（必须掌握的知识点）</p>
<p>2、模拟块级作用域，减少全局变量。执行完匿名函数，存储在内存中相对应的变量会被销毁，使用块级作用域，会大大降低命名冲突的问题，不必担心搞乱全局作用域了。</p>
<h3 id="JS垃圾回收机制-（GC）"><a href="#JS垃圾回收机制-（GC）" class="headerlink" title="JS垃圾回收机制 （GC）"></a>JS垃圾回收机制 （GC）</h3><ol>
<li>项目中，<strong>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢。当某些代码操作不能被合理释放，就会造成内存泄漏。我们尽可能减少使用闭包，因为它会消耗内存。</strong></li>
<li>浏览器垃圾回收机制/内存回收机制:浏览器的<strong>Javascript</strong>具有自动垃圾回收机制(GC:Garbage Collecation)，垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。</li>
</ol>
<p><strong>标记清除</strong>:在js中，最常用的垃圾回收机制是标记清除：<strong>当变量进入上下文，比如在函数内声明了一个变量时，这个变量就会被加上存在于上下文中的标记，而在上下文中的变量，逻辑上讲永远不应该释放他们的内存，因为只要在上下文中的代码运行了，就可能用到它们，当变量离开上下文中的时候，也会被加上离开上下文的标记。（上下文中的变量都访问不到他们了）</strong>垃圾回收器会<strong>销毁那些带离开上下文标记的值并回收它们所占用的内存空间</strong>。谷歌浏览器：“查找引用”，浏览器不定时去查找当前内存的引用，如果没有被占用了，浏览器会回收它；如果被占用，就不能回收。<br>过程</p>
<ol>
<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li>
<li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li>
<li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li>
<li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收<br>优点 ：</li>
</ol>
<p>标记清除算法的优点只有一个，那就是<strong>实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</strong></p>
<p>缺点</p>
<p>标记清除算法有一个很大的缺点，就是在<strong>清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片</strong>，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的</p>
<p>IE浏览器：<strong>“引用计数法”</strong>，当前内存被占用一次，计数累加1次，移除占用就减1，减到0时，浏览器就回收它。<br>缺点<br>引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是<strong>无法解决循环引用无法回收的问题，这也是最严重的</strong></p>
<ol>
<li>优化手段：内存优化 ; 手动释放：取消内存的占用即可。（1）堆内存：fn = null 【null：空指针对象】（2）栈内存：把上下文中，被外部占用的堆的占用取消即可。</li>
<li>内存泄漏在 JS 中，常见的内存泄露主要有 4 种,全局变量、闭包、DOM 元素的引用、定时器</li>
</ol>
<h4 id="V8对GC的优化-（待）"><a href="#V8对GC的优化-（待）" class="headerlink" title="V8对GC的优化  （待）"></a>V8对GC的优化  （待）</h4><ol>
<li>分代式垃圾回收</li>
</ol>
<p>V8 的垃圾回收策略主要基于分代式垃圾回收机制，<strong>V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收</strong></p>
<p>新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大<br>2. 新老生代<br>3. 新生代垃圾回收<br>4. 老生代垃圾回收<br>5. 为什么需要分代式？<br>6. 并行回收(Parallel)</p>
<p><strong>所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作</strong><br>7. 增量标记与懒性清理<br>8. 并发回收(Concurrent)</p>
<p><strong>它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起</strong><br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2022/03/26/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%90%97/">博客</a></p>
<h3 id="new-操作符具体干了什么呢？如何实现？"><a href="#new-操作符具体干了什么呢？如何实现？" class="headerlink" title="new 操作符具体干了什么呢？如何实现？"></a>new 操作符具体干了什么呢？如何实现？</h3><p>（1）首先创建了一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<p>new共经历了四个过程。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> fnObj = <span class="hljs-keyword">new</span> fn();<br><br><span class="hljs-number">1</span>、创建了一个空对象<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br><span class="hljs-number">2</span>、设置原型链<br>obj._proto_ = fn.prototype;<br><br><span class="hljs-number">3</span>、让fn的<span class="hljs-built_in">this</span>指向obj，并执行fn的函数体<br><br><span class="hljs-keyword">var</span> result = fn.call(obj);<br><br><span class="hljs-number">4</span>、判断fn的返回值类型，如果是值类型，返回obj。如果是引用类型，就返回这个引用类型的对象。<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(result) == <span class="hljs-string">&quot;object&quot;</span>)&#123;      fnObj = result;  &#125; <span class="hljs-keyword">else</span> &#123;      fnObj = obj;&#125;  <br><span class="hljs-comment">// 实现:</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>,<br>    <span class="hljs-title">constructor</span> = <span class="hljs-title">Array</span>.<span class="hljs-title">prototype</span>.<span class="hljs-title">shift</span>.<span class="hljs-title">call</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>),<br>    <span class="hljs-title">result</span> = <span class="hljs-title">null</span>;<br><br> <span class="hljs-comment">// 参数判断</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title">constructor</span> !== &quot;<span class="hljs-title">function</span>&quot;) &#123;<br> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;type error&quot;</span>);<br> <span class="hljs-keyword">return</span>;<br>  &#125;<br><br> <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br><br> <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">newObject, <span class="hljs-built_in">arguments</span></span>);<br><br> <span class="hljs-comment">// 判断返回对象</span><br> <span class="hljs-keyword">let</span> flag =<br>    result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br><br> <span class="hljs-comment">// 判断返回结果</span><br> <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-comment">// objectFactory(构造函数, 初始化参数);</span><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/07/02/JS%20new%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/">博客</a></p>
<h3 id="JavaScript-原型，原型链？-有什么特点？"><a href="#JavaScript-原型，原型链？-有什么特点？" class="headerlink" title="JavaScript 原型，原型链？ 有什么特点？"></a>JavaScript 原型，原型链？ 有什么特点？</h3><p>在 js 中我们是<strong>使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</strong></p>
<p>当我们使用构造函数新建一个对象后，<strong>在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值</strong>，在 ES5 中这个指针被称为对象的原型。</p>
<p>一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了<code>__proto__</code>属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个Object.<strong>getPrototypeOf() 方法</strong>，我们可以通过这个方法来获取对象的原型。</p>
<p>当我们<strong>访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype</strong>所以这就是我们新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p>2、隐式原型也是一个对象,是指向我们构造函数的原型</p>
<p>3、除了最顶层的Object对象没有__proto_，其他所有的对象都有__proto__,这是隐式原型</p>
<p>4、<strong>隐式原型__proto__的作用是让对象通过它来一直往上查找属性或方法，直到找到最顶层的Object的__proto__属性，它的值是null,这个查找的过程就是原型链</strong><br>特点：<br>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。<br><img src="/imageO/YX.jpg" srcset="/img/loading.gif" lazyload alt="原型链"></p>
<h4 id="面试题–原型链的顶端是什么（如果找不到是什么）"><a href="#面试题–原型链的顶端是什么（如果找不到是什么）" class="headerlink" title="面试题–原型链的顶端是什么（如果找不到是什么）"></a>面试题–原型链的顶端是什么（如果找不到是什么）</h4><p>在JavaScript中，每个对象都有一个原型（prototype）属性，指向它的原型对象。原型对象也有原型属性，指向它的原型对象，这样就形成了原型链。</p>
<p>原型链的顶端是Object.prototype，它是所有对象的祖先对象。<strong>Object.prototype的原型指向null，即它没有原型对象</strong>，所以<strong>当在原型链中找不到某个属性或方法时，就会返回undefined</strong>，而不是继续查找。</p>
<p>例如，当我们创建一个对象，并尝试访问它的属性或方法时，JavaScript引擎会先查找该对象本身是否具有该属性或方法，如果没有，则沿着原型链向上查找，直到找到该属性或方法或者到达Object.prototype为止。如果在整个原型链上都没有找到该属性或方法，那么就返回undefined。</p>
<p>总之，<strong>原型链的顶端是Object.prototype，它是所有对象的祖先对象</strong>，当在原型链中<strong>找不到某个属性或方法时，就会返回undefined</strong>。（这个答错了，回答的是null）</p>
<h4 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h4><p>p.<code>__proto__</code><br>p.constructor.prototype<br>Object.getPrototypeOf(p)</p>
<h4 id="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"><a href="#hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链" class="headerlink" title="hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链"></a>hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链</h4><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><h4 id="1-没有-this"><a href="#1-没有-this" class="headerlink" title="1.没有 this"></a>1.没有 this</h4><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p>
<h5 id="箭头函数this为父作用域的this，不是调用时的this"><a href="#箭头函数this为父作用域的this，不是调用时的this" class="headerlink" title="箭头函数this为父作用域的this，不是调用时的this"></a>箭头函数this为父作用域的this，不是调用时的this</h5><p><img src="/imageO/JTHS.jpg" srcset="/img/loading.gif" lazyload alt="this"><br>箭头函数的<strong>this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind</strong>。</p>
<p>普通函数的this指向调用它的那个对象。</p>
<blockquote>
<p>上例中，init为箭头函数，其内部的this为全局window，onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</p>
</blockquote>
<h4 id="2-没有-arguments-（arguments是一个类数组对象，用来存储实际传递给函数的参数）"><a href="#2-没有-arguments-（arguments是一个类数组对象，用来存储实际传递给函数的参数）" class="headerlink" title="2.没有 arguments  （arguments是一个类数组对象，用来存储实际传递给函数的参数）"></a>2.没有 arguments  （arguments是一个类数组对象，用来存储实际传递给函数的参数）</h4><p>箭头函数没有自己的 arguments 对象，这不一定是件坏事，因为箭头函数可以访问外围函数的 arguments 对象：<br>那如果我们就是要访问箭头函数的参数呢？<br>你可以通过<strong>命名参数或者 rest 参数的形式访问参数</strong>:<br>let nums = (…nums) =&gt; nums;</p>
<h5 id="…args剩余参数和-arguments对象的区别"><a href="#…args剩余参数和-arguments对象的区别" class="headerlink" title="…args剩余参数和 arguments对象的区别"></a>…args剩余参数和 arguments对象的区别</h5><p>剩余参数只包含那些<strong>没有对应形参的实参</strong>，而 arguments 对象包含了传给函数的<strong>所有实参</strong>。<br>arguments对象<strong>不是一个真正的数组（类数组）</strong>，而<strong>剩余参数是真正的 Array实例</strong>，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。<br>arguments对象还有一些附加的属性 （如callee属性）。</p>
<h4 id="3-不能通过-new-关键字调用"><a href="#3-不能通过-new-关键字调用" class="headerlink" title="3.不能通过 new 关键字调用"></a>3.不能通过 new 关键字调用</h4><p>JavaScript 函数有两个内部方法： <strong>[[Call]]</strong> 和 **[[Construct]]**。</p>
<p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p>
<p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。</p>
<p>箭头函数并没有 [[Construct]] 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo(); <span class="hljs-comment">// TypeError: Foo is not a constructor</span><br></code></pre></td></tr></table></figure>
<h4 id="4-没有-new-target"><a href="#4-没有-new-target" class="headerlink" title="4.没有 new.target"></a>4.没有 new.target</h4><p>因为不能使用 new 调用，所以也没有 new.target 值。</p>
<p>关于 new.target，可以参考 <a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7">es6</a></p>
<h4 id="5-没有原型"><a href="#5-没有原型" class="headerlink" title="5.没有原型"></a>5.没有原型</h4><p>由于不能使用 new 调用箭头函数，所以也没有构建原型的需求，于是箭头函数也不存在 prototype 这个属性。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">var Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(Foo.prototype); <span class="hljs-regexp">//</span> <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure>
<h5 id="解释——箭头函数为什么不能当做构造函数-（不能被实例化）"><a href="#解释——箭头函数为什么不能当做构造函数-（不能被实例化）" class="headerlink" title="解释——箭头函数为什么不能当做构造函数 （不能被实例化）"></a>解释——箭头函数为什么不能当做构造函数 （不能被实例化）</h5><p>一句话解释：</p>
<p>因为箭头函数没有 [ [Construct] ] 方法<br>和ES6的类的概念有点像，如果一个类没有定义constructor，直接new也会报错</p>
<h4 id="6-没有-super"><a href="#6-没有-super" class="headerlink" title="6.没有 super"></a>6.没有 super</h4><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>
<h4 id="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数"><a href="#箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或-new-target。这些函数表达式最适合用于非方法函数-non-method-functions-，并且它们不能用作构造函数" class="headerlink" title="箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数"></a>箭头函数表达式的语法比函数表达式更短，并且不绑定自己的this，arguments，super或 new.target。这些函数表达式最适合用于非方法函数(non-method functions)，并且它们不能用作构造函数</h4><h4 id="扩展-面试题"><a href="#扩展-面试题" class="headerlink" title="扩展(面试题)"></a>扩展(面试题)</h4><h5 id="类里面可以用箭头函数嘛"><a href="#类里面可以用箭头函数嘛" class="headerlink" title="类里面可以用箭头函数嘛"></a>类里面可以用箭头函数嘛</h5><p>在JavaScript的类中，<strong>可以使用箭头函数</strong>，但是<strong>需要注意箭头函数的this指向</strong>。</p>
<p>在箭头函数中，this的值是在定义函数时确定的，而不是在运行时确定的。这意味着如果<strong>箭头函数中引用了this，它将指向箭头函数定义时的上下文，而不是类实例</strong>。</p>
<p>在大多数情况下，我们需要访问类实例中的属性和方法，因此在类中定义方法时通常使用传统函数语法而不是箭头函数。但是，<strong>在某些情况下，比如定义只读属性时，箭头函数可能更方便。</strong></p>
<p>以下是一个例子，展示了在类中使用箭头函数的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.greet = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>.`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 只读属性</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">description</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span> is a person.`</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>);<br>person.greet(); <span class="hljs-comment">// 输出 &quot;Hello, my name is Alice.&quot;</span><br><span class="hljs-built_in">console</span>.log(person.description); <span class="hljs-comment">// 输出 &quot;Alice is a person.&quot;</span><br></code></pre></td></tr></table></figure>
<h5 id="为什么有的时候可以用箭头函数有的时候不可以用"><a href="#为什么有的时候可以用箭头函数有的时候不可以用" class="headerlink" title="为什么有的时候可以用箭头函数有的时候不可以用"></a>为什么有的时候可以用箭头函数有的时候不可以用</h5><p>箭头函数与普通函数语法的一个主要区别是<strong>它们的this绑定方式不同</strong>。</p>
<p>在普通函数中，this的值是在运行时确定的，它取决于函数是如何调用的。this的值可以在函数调用时使用bind、call或apply方法进行修改。而<strong>在箭头函数中，this的值在函数定义时就已经确定，它始终指向箭头函数定义时所在的上下文，而不是调用时的上下文</strong>。</p>
<p>这就意味着，在某些情况下，箭头函数不适合使用。例如，<strong>在需要动态绑定this的情况下，箭头函数就不太合适</strong>。另外，<strong>在类的方法中，通常需要访问类实例的属性和方法</strong>，因此在这种情况下使用箭头函数可能会导致意外的行为。</p>
<p>另外一个需要注意的地方是，箭头函数不可以作为构造函数使用，因为它们没有自己的this绑定。在尝试使用箭头函数作为构造函数时，JavaScript会抛出一个TypeError错误。<br>因此，在选择使用箭头函数还是普通函数时，需要考虑到函数的用途和上下文，以确保正确的this绑定和预期的行为。</p>
<h5 id="在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例"><a href="#在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例" class="headerlink" title="在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例"></a>在类的方法中，通常需要访问类实例的属性和方法，因此在这种情况下使用箭头函数可能会导致意外的行为。代码示例</h5><p>当在类中使用箭头函数作为方法时，this将会指向箭头函数定义时所在的上下文，而不是类实例。这可能会导致一些意外的行为，例如无法访问类实例的属性或方法。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用箭头函数定义方法</span><br>  printDetails = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, Age: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><br><span class="hljs-comment">// 调用方法，输出 &quot;Name: undefined, Age: undefined&quot;</span><br>person.printDetails();<br><br><span class="hljs-comment">// 尝试访问实例属性，输出 &quot;Alice&quot;</span><br><span class="hljs-built_in">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用箭头函数定义了一个名为printDetails的方法。当我们创建Person实例并调用该方法时，它会输出undefined，<strong>因为箭头函数的this指向Person类的定义上下文，而不是实例</strong>。因此，this.name和this.age都是undefined。此外，在类外部访问实例属性和方法时，它们仍然是可以访问的。</p>
<p>为了避免这种问题，我们通常<strong>使用普通函数语法</strong>定义类的方法，它们具有正确的this绑定，可以访问实例的属性和方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br><br>  <span class="hljs-comment">// 使用普通函数定义方法</span><br>  <span class="hljs-function"><span class="hljs-title">printDetails</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>, Age: <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">25</span>);<br><br><span class="hljs-comment">// 调用方法，输出 &quot;Name: Alice, Age: 25&quot;</span><br>person.printDetails();<br><span class="hljs-comment">// 尝试访问实例属性，输出 &quot;Alice&quot;</span><br><span class="hljs-built_in">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用普通函数定义了printDetails方法，它具有正确的this绑定，可以访问实例的属性和方法。在创建Person实例并调用该方法时，它会输出正确的实例属性值。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903616231260174#heading-4">参考文章</a></p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>谈一谈你对this的理解，以及在各种环境下的this<br>在浏览器里，在全局范围内this指向window对象<br>在函数中，this永远指向最后调用他的那个对象(箭头函数除外)。<br>在构造函数中，this指向new出来的新对象。<br>call、apply、bind中的this被强绑定在指定的那个对象上。<br>箭头函数this为父作用域的this，不是调用时的this。<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/12/JS&this%E6%8C%87%E5%90%91/">博客：</a></p>
<h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title="call() 和 .apply() 的区别？"></a>call() 和 .apply() 的区别？</h3><ol>
<li>它们的作用一模一样，区别仅在于传入参数的形式的不同。</li>
<li><strong>call 传入的参数数量不固定</strong>，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ol>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Function.call(obj,<span class="hljs-comment">[param1<span class="hljs-comment">[,param2<span class="hljs-comment">[,…<span class="hljs-comment">[,paramN]</span>]</span>]</span>]</span>)<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p>
</li>
<li><p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>
</li>
</ol>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">function add (a, b) &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>function <span class="hljs-function"><span class="hljs-keyword">sub</span> (<span class="hljs-title">a</span>, <span class="hljs-title">b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a - b;<br>&#125;<br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>; // 这时，并不会返回 <span class="hljs-number">8</span><br>add.bind(<span class="hljs-function"><span class="hljs-keyword">sub</span>, 5, 3)</span>(); // 调用后，返回 <span class="hljs-number">8</span><br><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/05/14/Js&call&apply&bind/">博客：</a></p>
<h3 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h3><p>相关知识点：<br>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。<br>post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。</p>
<p>回答：<br>缓存一般只适用于那些不会更新服务端数据的请求。一般 get 请求都是查找请求，不会对服务器资源数据造成修改</p>
<h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>GET请求的数据会附加在URL之后，用问号分割，多个参数用&amp;进行连接。<br>GET请求的数据会暴露在地址栏中。<br>GET请求URL的编码格式采用的是ASCII编码，而不是Unicode编码。<br>GET请求传输大小有限制，大小在<strong>2KB。</strong><br>GET相对<strong>安全性较差，会被浏览器主动缓存。</strong><br>GET产生一个TCP数据包，head和data一起发送。<br>GET浏览器回退无害。</p>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>POST请求会把数据放置在HTTP请求包的包体中，不会直接暴露给用户。<br>POST请求，理论上大小是不会限制的，但是实际上各个服务器会规定POST提交数据大小。<br>POST相对Get更安全，因为参数不会保存浏览器立式或者是web服务器日志中。<br>POST产生两个TCP数据包，header先发送，服务器响应100ms然后继续，发送data，服务器200然后返回数据。<br>POST浏览器回退重新请求。<br>其他http方法</p>
<h3 id="setTimeout输出值的时候，如何实现i按序输出？"><a href="#setTimeout输出值的时候，如何实现i按序输出？" class="headerlink" title="setTimeout输出值的时候，如何实现i按序输出？"></a>setTimeout输出值的时候，如何实现i按序输出？</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">55555</span><br></code></pre></td></tr></table></figure>

<p>这道题挺经典的，输出结果是什么呢？结果是1000毫秒之后，输出5个5（隔一秒输出在1000上乘个i就行）<br><strong>原因是，for循环在主线程内，setTimeout是异步方法，在任务队列里面，只有主线程执行完后，任务队列才执行，此时i的值已经是5，所以得到结果是5个5</strong></p>
<p>那么怎么解决呢？其实思路很容易，只要每次循环把当前的i值传入setTimeout内即可</p>
<h4 id="方法1：使用let"><a href="#方法1：使用let" class="headerlink" title="方法1：使用let"></a>方法1：使用let</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br>//<span class="hljs-number">01234</span><br></code></pre></td></tr></table></figure>

<p>使用let 相当于每次循环的时候都新建了1个i并为其赋值</p>
<p>这是因为第一个代码块中setTimeout 的 console.log(i); 的i是 var 定义的，所以是函数级的作用域，不属于 for 循环体，属于 全局变量。等到 for 循环结束，i 已经等于 5 了，这个时候再执行 setTimeout 的五个回调函数（参考上面对事件机制的阐述），里面的 console.log(i); 的 i 去向上找作用域，只能找到 全局作用下 的 i，即 5。所以输出都是 5。</p>
<p>而let是代码块的作用域，即是局部变量，所以每一次 for 循环，console.log(i); 都引用到 for 代码块作用域下的i，因为这样被引用，所以 for 循环结束后，这些作用域在 setTimeout 未执行前都不会被释放。</p>
<h4 id="方法2：定义函数并传值"><a href="#方法2：定义函数并传值" class="headerlink" title="方法2：定义函数并传值"></a>方法2：定义函数并传值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);        <br>    &#125;<br>    a(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法3：IIFE（立即执行函数）"><a href="#方法3：IIFE（立即执行函数）" class="headerlink" title="方法3：IIFE（立即执行函数）"></a>方法3：IIFE（立即执行函数）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    ~<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(i)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>MDN<br>IIFE（立即调用函数表达式）<br>IIFE（ 立即调用函数表达式）是一个在定义时就会立即执行的  JavaScript 函数。</p>
</blockquote>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span> () &#123;<br>    statements<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p>
<p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p>
<h4 id="方法4：使用闭包"><a href="#方法4：使用闭包" class="headerlink" title="方法4：使用闭包"></a>方法4：使用闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span><br>            () =&gt; <span class="hljs-built_in">console</span>.log(i)<br>        )(i), <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数"><a href="#方法5：setTimeout第三个参数传入i-是的，你没看错，setTimeout还有第三个参数" class="headerlink" title="方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)"></a>方法5：setTimeout第三个参数传入i(是的，你没看错，setTimeout还有第三个参数)</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">for</span> (var i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">(i)</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(i),<span class="hljs-number">1000</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="正确定义的匿名函数"><a href="#正确定义的匿名函数" class="headerlink" title="正确定义的匿名函数"></a>正确定义的匿名函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 由于没有执行该匿名函数，所以不会执行匿名函数体内的语句。</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;zxx&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="小括号的作用"><a href="#小括号的作用" class="headerlink" title="小括号的作用"></a>小括号的作用</h4><p>小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。 通俗点讲就是，加入小括号后就实现了和具名函数一样的形式</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903962257129485">详解JavaScript的匿名函数（面试重点）</a></p>
<h3 id="深拷贝和浅拷贝-赋值"><a href="#深拷贝和浅拷贝-赋值" class="headerlink" title="深拷贝和浅拷贝||赋值"></a>深拷贝和浅拷贝||赋值</h3><p>相关资料：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-comment">// 只拷贝对象</span><br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br> <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br><br><span class="hljs-comment">// 深拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return <span class="hljs-keyword">object</span>;<br><br> <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>[<span class="hljs-params">key</span>])</span>;<br>    &#125;<br>  &#125;<br><br> return newObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>JS的基本类型不存在浅拷贝还是深拷贝的问题,深拷贝与浅拷贝的概念<strong>只存在于引用类型。</strong></li>
<li>对于仅仅是复制了引用（地址），换句话说，复制了之后，<strong>原来的变量和新的变量指向同一个东西，彼此之间的操作会互相影响，为 浅拷贝。而如果是在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象是完全隔离，互不影响，为 深拷贝。</strong></li>
</ol>
<p>利用{…}（剩余运算符，不定参数）实现拷贝。注意这里是拷贝，先不区分是深还是浅</p>
<p><strong>如果是引用类型，且只有一层对象</strong>，则<strong>这一层就是深拷贝。拷贝前后，对象的基本类型互不影响</strong>，<br>如果是引用类型，<strong>且有两层以上嵌套对象，则这嵌套的，就是浅拷贝</strong>。嵌套的对象，拷贝的嵌套对象的引用。<strong>拷贝前后，嵌套对象数据相互影响，一层对象，互不影响</strong><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6963515965791272967">掘金</a></p>
<ol>
<li>深浅拷贝 的主要区别就是：复制的是引用(地址)还是复制的是实例。</li>
</ol>
<p>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用<strong>Object.assign 和展开运算符</strong>来实现。</p>
<p>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败。<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/17/javascript%20%E5%85%B3%E4%BA%8E%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/#%E4%BE%8B">博客：</a></p>
<h5 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h5><ol>
<li>Object.assign()</li>
<li>Array.prototype.concat()</li>
<li>Array.prototype.slice()</li>
<li>展开运算符…</li>
<li>函数库lodash的_.clone方法</li>
</ol>
<h5 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h5><ol>
<li>JSON.parse()</li>
<li>JSON.stringify()</li>
<li>函数库lodash的_.cloneDeep方法</li>
<li>jQuery.extend()方法</li>
<li>手写递归方法<br>参考<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904197595332622#heading-3">掘金</a></li>
</ol>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><ol>
<li>当我们把一个变量赋值给另一个变量时，是在<strong>栈内存中新增一个变量</strong>，并且赋值。<strong>二者互不影响</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> c = <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> d = c<br>d = <span class="hljs-number">2</span><br><span class="hljs-built_in">console</span>.log(c) <span class="hljs-comment">//c1</span><br><span class="hljs-built_in">console</span>.log(d) <span class="hljs-comment">//2</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>当我们把一个对象赋值给一个新的对象时,<strong>赋的是该对象在栈中的地址，而不是堆中的数据，也就是赋值之后，两个对象指向同一个存储空间。无论哪个对象发生改变，其实都是改变的堆中的数据(会互相影响，指向的引用地址都相同)</strong></li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">let a = &#123;<br><span class="hljs-type">name</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br><span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;吃饭&#x27;</span>]<br>&#125;<br>let b = a<br><br>b.name = <span class="hljs-string">&#x27;b&#x27;</span><br>b.<span class="hljs-keyword">like</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;睡觉&#x27;</span><br>console.log(<span class="hljs-string">&#x27;a&#x27;</span>, a) //a &#123;<span class="hljs-type">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">like</span>: <span class="hljs-keyword">Array</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;睡觉&#x27;</span>]<span class="hljs-type">name</span>: &quot;b&quot;<br>console.log(<span class="hljs-string">&#x27;b&#x27;</span>, b)//b  &#123;<span class="hljs-type">name</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-keyword">like</span>: <span class="hljs-keyword">Array</span>(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">like</span>: [<span class="hljs-string">&#x27;睡觉&#x27;</span>]<span class="hljs-type">name</span>: &quot;b&quot;<br>打印的一样<br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6963515965791272967">掘金</a></p>
<h4 id="slice（不会改变原始数组）-和-concat（不会更改现有数组，而是返回一个新数组）"><a href="#slice（不会改变原始数组）-和-concat（不会更改现有数组，而是返回一个新数组）" class="headerlink" title="slice（不会改变原始数组） 和 concat（不会更改现有数组，而是返回一个新数组）"></a>slice（不会改变原始数组） 和 concat（不会更改现有数组，而是返回一个新数组）</h4><p>Array 的 slice 和 concat 方法 和 jQuery 中的 extend 复制方法，他们都会复制第一层的值，对于 第一层 的值都是 深拷贝，而到 第二层 的时候 Array 的 slice 和 concat 方法就是 复制引用 ，jQuery 中的 extend 复制方法 则 取决于 你的 第一个参数， 也就是是否进行递归复制。所谓第一层 就是 key 所对应的 value 值是基本数据类型，也就像上面栗子中的name、age，而对于 value 值是引用类型 则为第二层，也就像上面栗子中的 company。</p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="ES6-语法知道哪些，分别怎么用？"><a href="#ES6-语法知道哪些，分别怎么用？" class="headerlink" title="ES6 语法知道哪些，分别怎么用？"></a>ES6 语法知道哪些，分别怎么用？</h3><p>let const 块级作用域 箭头函数 词法this Class 解构，剩余运算符，Promise等，往这些方面展开。 不定参数…rest</p>
<h4 id="let与var对比-做项目中习惯用let声明变量"><a href="#let与var对比-做项目中习惯用let声明变量" class="headerlink" title="let与var对比(做项目中习惯用let声明变量)"></a>let与var对比(做项目中习惯用let声明变量)</h4><p>var声明的变量往往会越狱 (let 是在代码块内有效，var 是在全局范围内有效:)<br>let声明的变量有严格局部作用域<br>var可以声明多次，let只能声明一次<br>let 不存在变量提升var 会变量提升 （undefined）</p>
<h4 id="const声明变量-只读变量"><a href="#const声明变量-只读变量" class="headerlink" title="const声明变量 (只读变量)"></a>const声明变量 (只读变量)</h4><p>声明之后不允许改变<br><strong>一旦声明必须初始化，否者会报错</strong><br>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，<strong>而是保证变量指向的内存地址所保存的数据不允许改动</strong><br>解释：<br>对于简单类型的数据（数值、字符串、布尔值），<strong>值就保存在变量指向的那个内存地址，因此等同于常量</strong>。但对于<strong>复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针</strong>，const<strong>只能保证这个指针是固定的（即总是指向另一个固定的地址）</strong>，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<h3 id="Set-Map-Reduce"><a href="#Set-Map-Reduce" class="headerlink" title="Set  Map  Reduce"></a>Set  Map  Reduce</h3><blockquote>
<p>Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构<br>Set中两个对象永远是不相等的，即使键和值都是一样的</p>
</blockquote>
<h4 id="Map的特点？Map类似于对象，也是键值对的集合"><a href="#Map的特点？Map类似于对象，也是键值对的集合" class="headerlink" title="Map的特点？Map类似于对象，也是键值对的集合"></a>Map的特点？Map类似于对象，也是键值对的集合</h4><p>方法(1. set2. get3. has4. delete5. clear)<br>6. Map默认情况下不包含任何键，所有键都是开发人员添加进去的。不像Object原型链上有一些默认的键。<br>7. Map的键可以是<strong>任意类型数据，就连函数都可以</strong>。Object的键<strong>只能是String或Symbol。</strong><br>8. Map的键值<strong>对个数可以轻易通过size属性获取，Object需要手动计算。</strong><br>9. Map在<strong>频繁增删键值对</strong>的场景下性能要比Object好。</p>
<h4 id="什么时候用Map？"><a href="#什么时候用Map？" class="headerlink" title="什么时候用Map？"></a>什么时候用Map？</h4><p>要<strong>添加的键值名和Object上的默认键值名冲突，又不想改名时，</strong>可以换用Map。 JS对象自己的对象属性可能会与从原型继承的属性键冲突（例如 toString，constructor等）。<br>需要<strong>String和Symbol以外的数据类型</strong>做键值时，用Map。<br><strong>键值对很多，有需要计算数量时，用Map。</strong><br>需要<strong>频繁增删键值对</strong>时，用Map。</p>
<p><strong>Map()和map是不一样的</strong></p>
<blockquote>
<p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/14/Map&&Set&&Weakmap&&Weakset/">博客：</a></p>
</blockquote>
<p><img src="/imageO/Reduce.jpg" srcset="/img/loading.gif" lazyload alt="Reduce"></p>
<h3 id="Map-和-WeakMap-的区别"><a href="#Map-和-WeakMap-的区别" class="headerlink" title="Map 和 WeakMap 的区别"></a>Map 和 WeakMap 的区别</h3><p>1.Map <strong>的键可以是任意类型，WeakMap  只接受对象作为键（null除外），不接受其他类型的值作为键</strong></p>
<ol>
<li>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键； WeakMap 的键是<strong>弱引用，键所指向的对象可以被垃圾回收，此时键是无效的</strong></li>
<li><strong>Map 可以被遍历， WeakMap 不能被遍历</strong></li>
</ol>
<h4 id="WeakMap的使用场景（Map-和-Weakmap-之间的主要区别是，Weakmap-允许对键对象进行垃圾收集，从而防止内存泄漏。）"><a href="#WeakMap的使用场景（Map-和-Weakmap-之间的主要区别是，Weakmap-允许对键对象进行垃圾收集，从而防止内存泄漏。）" class="headerlink" title="WeakMap的使用场景（Map 和 Weakmap 之间的主要区别是，Weakmap 允许对键对象进行垃圾收集，从而防止内存泄漏。）"></a>WeakMap的使用场景（Map 和 Weakmap 之间的主要区别是，Weakmap 允许对键对象进行垃圾收集，从而防止内存泄漏。）</h4><ol>
<li>DOM 节点元数据<br>因为 weakMap 不会影响垃圾回收，所以可以用来<strong>关联元数据</strong></li>
<li>部署私有属性<br>利用弱映射，<strong>将内部属性设置为实例的弱引用对象，当实例删除时，私有属性也会随之消失</strong>，因此不会内存泄漏</li>
<li>数据缓存<br>当我们<strong>需要在不修改原有对象的情况下储存某些属性等，而又不想管理这些数据时</strong>，可以使用WeakMap<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/14/Map&&Set&&Weakmap&&Weakset/#%E4%BA%94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-WeakMap-%EF%BC%9F">博客</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6993101968545677319#heading-18">浅析 Map 和 WeakMap 区别以及使用场景</a></li>
</ol>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化就是把代码进行拆分，方便重复利用，类似java中的导包，需要使用一个包，必须先导包，而js中没有包的概念，换来的是模块<br>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p>
<h4 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h4><p>避免命名冲突（减少命名空间污染）更好的分类，按需加载,更高的复用性,高可维护性</p>
<h3 id="CommomJS-node应用由模块组成"><a href="#CommomJS-node应用由模块组成" class="headerlink" title="CommomJS(node应用由模块组成)"></a>CommomJS(node应用由模块组成)</h3><p>CommonJS定义了两个主要概念：<br>require函数，用于导入模块<br>module.exports变量，用于导出模块<br>require导入，代码很简单，let {count,addCount}=require(“./utils”)就可以了。<br>require的第一步是解析路径获取到模块内容：</p>
<h3 id="ES6模块与CommonJS的区别"><a href="#ES6模块与CommonJS的区别" class="headerlink" title="ES6模块与CommonJS的区别"></a>ES6模块与CommonJS的区别</h3><h4 id="CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用"><a href="#CommonJS-模块输出的是一个值的拷贝，ES6-模块输出的是值的引用" class="headerlink" title="CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用"></a>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</h4><ol>
<li>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</li>
<li>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。</li>
<li>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，<strong>遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值</strong>。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
</ol>
<h4 id="CommonJS-模块是运行时加载，ES6-模块是编译时输出接口"><a href="#CommonJS-模块是运行时加载，ES6-模块是编译时输出接口" class="headerlink" title="CommonJS 模块是运行时加载，ES6 模块是编译时输出接口"></a>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</h4><ol>
<li>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</li>
<li>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</li>
</ol>
<h4 id="CommonJs导出有有缓存，而ES6没有"><a href="#CommonJs导出有有缓存，而ES6没有" class="headerlink" title="CommonJs导出有有缓存，而ES6没有"></a>CommonJs导出有有缓存，而ES6没有</h4><p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2022/03/01/CommonJS%E5%92%8CES6%E6%A8%A1%E5%9D%97/">博客</a></p>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/">博客：</a></p>
<h3 id="ECMAScript6-怎么写-class，为什么会出现-class-这种东西"><a href="#ECMAScript6-怎么写-class，为什么会出现-class-这种东西" class="headerlink" title="ECMAScript6 怎么写 class，为什么会出现 class 这种东西?"></a>ECMAScript6 怎么写 class，为什么会出现 class 这种东西?</h3><p>在我看来 ES6 新添加的 class 只是为了补充 js 中缺少的一些<strong>面向对象语言的特性</strong>，但本质上来说它只是一种<strong>语法糖，不是一个新的东西，其背后还是原型继承的思想</strong>。通过加入 class 可以有利于我们更好的组织代码。在 class 中添加的方法，其实是添加在类的原型上的。</p>
<h2 id="数组-amp-amp-对象-方法（基础）"><a href="#数组-amp-amp-对象-方法（基础）" class="headerlink" title="数组&amp;&amp;对象 方法（基础）"></a>数组&amp;&amp;对象 方法（基础）</h2><h3 id="数组去重-indexOf-set-map-for-Object键值对"><a href="#数组去重-indexOf-set-map-for-Object键值对" class="headerlink" title="数组去重 (indexOf  set  map  for  Object键值对)"></a>数组去重 (indexOf  set  map  for  Object键值对)</h3><p>法一：indexOf循环去重<br>法二：ES6 Set去重；Array.from(new Set(array))<br>法三：Object 键值对去重；把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904121380667399#heading-65">掘金</a></p>
<h3 id="数组常用方法-一般方法"><a href="#数组常用方法-一般方法" class="headerlink" title="数组常用方法(一般方法)"></a>数组常用方法(一般方法)</h3><p>push()，pop()，shift()，unshift()，splice()，sort()，reverse()，map()等</p>
<h4 id="会改变原始数组的方法有"><a href="#会改变原始数组的方法有" class="headerlink" title="会改变原始数组的方法有"></a>会改变原始数组的方法有</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  压入到尾部        pop:  弹出尾部的一个元素<br>unshift  压入到头部           shift    弹出头部的一个元素<br><span class="hljs-function"><span class="hljs-title">sort</span><span class="hljs-params">()</span></span>  方法用于对数组的元素进行排序。 排序顺序可以是字母或数字，并按升序或降序。默认排序顺序为按字母升序。<br><span class="hljs-function"><span class="hljs-title">reverse</span><span class="hljs-params">()</span></span>   方法用于颠倒数组中元素的顺序。<br><span class="hljs-function"><span class="hljs-title">splice</span><span class="hljs-params">()</span></span>    方法用于添加或删除数组中的元素。注意：这种方法会改变原始数组。<br><br></code></pre></td></tr></table></figure>

<h4 id="不改变原始数组的方法有"><a href="#不改变原始数组的方法有" class="headerlink" title="不改变原始数组的方法有"></a>不改变原始数组的方法有</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">filter</span>()   返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组<br>concat()   方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br><span class="hljs-keyword">slice</span>() 截取<span class="hljs-keyword">Array</span>的一部分，返回一个新数组，类似于String中的substring  [)<br>map()   <span class="hljs-keyword">forEach</span>()   (数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)<br>every、<span class="hljs-keyword">some</span>、<span class="hljs-keyword">filter</span>、reduce ES6新增的方法entries、find、findIndex、keys、<span class="hljs-keyword">values</span><br></code></pre></td></tr></table></figure>

<h3 id="数组和对象方法（进阶）"><a href="#数组和对象方法（进阶）" class="headerlink" title="数组和对象方法（进阶）"></a>数组和对象方法（进阶）</h3><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。<br>find(返回数组中满足条件的第一个元素的值，如果没有，返回undefined)<br>array.findeIndex(callback[,thisArg]) 返回数组中满足条件的第一个元素的下标，如果没有找到，返回**-1**</p>
<ol>
<li><p>数组常用的方法  find  filter  every  some</p>
</li>
<li><p>判断一个数组中有符合我需求的元素用哪个比较合适–indexof    find</p>
</li>
<li><p><strong>如果要返回一个布尔值—   includes  some every</strong></p>
</li>
</ol>
<h3 id="js字符串数组互转"><a href="#js字符串数组互转" class="headerlink" title="js字符串数组互转"></a>js字符串数组互转</h3><h4 id="字符串转数组"><a href="#字符串转数组" class="headerlink" title="字符串转数组"></a>字符串转数组</h4><ol>
<li>split() 方法  将字符串转换成一个数组</li>
<li>扩展运算符[…]  es6里面的扩展运算符</li>
<li>Array.from()方法  es6 Array.from()方法</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">split() 方法 <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;abc&quot;</span>.split(<span class="hljs-string">&#x27;&#x27;</span>)); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>] <br><br>扩展运算符[...] <br><span class="hljs-built_in">console</span>.log([...<span class="hljs-string">&quot;abc&quot;</span>]); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br><br> <span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>()方法<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br></code></pre></td></tr></table></figure>

<h4 id="数组转字符串"><a href="#数组转字符串" class="headerlink" title="数组转字符串"></a>数组转字符串</h4><p>toString()方法 将数组转换成一个字符串<br>toLocaleString()方法 把数组转换成本地约定的字符串<br>join()方法 将数组元素连接起来以构建一个字符串</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;;&#x27;</span>)); <span class="hljs-comment">// a;b;c </span><br>console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].<span class="hljs-built_in">toString</span>()); <span class="hljs-comment">// a;b;c </span><br>console.<span class="hljs-built_in">log</span>([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>].toLocaleString()); <span class="hljs-comment">// a;b;c </span><br></code></pre></td></tr></table></figure>

<h3 id="JS如何实现数组扁平化？"><a href="#JS如何实现数组扁平化？" class="headerlink" title="JS如何实现数组扁平化？"></a>JS如何实现数组扁平化？</h3><ol>
<li>ES6的flat</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ary = arr<span class="hljs-selector-class">.flat</span>(Infinity)<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-attr">[1, [2, 3, [4, 5]</span>]]<span class="hljs-selector-class">.flat</span>(Infinity))<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>正则处理</li>
<li>递归</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]</span>]];<br><br> <span class="hljs-keyword">function</span> flattern(arr,result =<span class="hljs-literal">[]</span>) &#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>[<span class="hljs-params">i</span>])</span>) &#123;<br>                flattern(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, result)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.push(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>console.log(flattern(arr));<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>reduce</li>
<li>toString</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/">博客地址</a></p>
<h3 id="JS求数组的交集、并集、差集"><a href="#JS求数组的交集、并集、差集" class="headerlink" title="JS求数组的交集、并集、差集"></a>JS求数组的交集、并集、差集</h3><p>现有两个数组</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = [<span class="hljs-number">101</span>,<span class="hljs-number">201</span>,<span class="hljs-number">601</span>]<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = [<span class="hljs-number">201</span>,<span class="hljs-number">301</span>,<span class="hljs-number">801</span>]<br></code></pre></td></tr></table></figure>

<h4 id="求交集（交集元素由既属于集合a又属于集合b的元素组成）"><a href="#求交集（交集元素由既属于集合a又属于集合b的元素组成）" class="headerlink" title="求交集（交集元素由既属于集合a又属于集合b的元素组成）"></a>求交集（交集元素由既属于集合a又属于集合b的元素组成）</h4><ol>
<li>方法1  filter  includes()</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let intersection = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.filter</span>(v =&gt; <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.includes</span>(v)) <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>方法2  filter  indexOf()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>&#123; <span class="hljs-keyword">return</span> b.indexOf(v) &gt; -<span class="hljs-number">1</span> &#125;) <span class="hljs-comment">//[201]</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>方法3  filter Set() set.has</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> intersection = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">filter</span>(<span class="hljs-params">v</span>=&gt; <span class="hljs-params">new</span> Set(<span class="hljs-params">b</span>)</span>.has(v))))  <span class="hljs-comment">//[201]</span><br><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>方法4  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> intersection = a.filter(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(b).has(v))  <span class="hljs-comment">// [201]</span><br></code></pre></td></tr></table></figure>

<h4 id="2-求并集-并集元素由集合a和集合b中所有元素去重组成"><a href="#2-求并集-并集元素由集合a和集合b中所有元素去重组成" class="headerlink" title="2.求并集 (并集元素由集合a和集合b中所有元素去重组成)"></a>2.求并集 (并集元素由集合a和集合b中所有元素去重组成)</h4><ol>
<li>方法1  filter  includes()</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let union = <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.concat</span>(<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.filter</span>(v=&gt; &#123;<br>   return !<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.includes</span>(v)<br> &#125;<br>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>方法2  Array.from()  Set()  concat() (最简单)</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> union = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>from(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Set(<span class="hljs-params">a</span>.<span class="hljs-params">concat</span>(<span class="hljs-params">b</span>)</span>)) <span class="hljs-comment">// [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>方法3    concat()  filter()  indexOf()</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">let <span class="hljs-built_in">union</span> = <span class="hljs-keyword">a</span>.concat(b.<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-title">v</span>) &#123;</span><br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>.indexOf(v) === <span class="hljs-number">-1</span><br>&#125;))<span class="hljs-comment"> // [101, 201, 601, 301, 801]</span><br></code></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2022/02/28/Js%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/">博客地址</a></p>
<h4 id="对象常用的方法–遍历一个对象-for-in-Object-keys-Object-values-Object-entries"><a href="#对象常用的方法–遍历一个对象-for-in-Object-keys-Object-values-Object-entries" class="headerlink" title="对象常用的方法–遍历一个对象  for in   Object.keys  Object.values  Object.entries"></a>对象常用的方法–遍历一个对象  for in   Object.keys  Object.values  Object.entries</h4><p>工作中遍历对象都用for  in 嘛，遍历用的比较多的方法是(有用过forEach嘛)</p>
<h5 id="ES6-Object新增的Api"><a href="#ES6-Object新增的Api" class="headerlink" title="ES6 Object新增的Api"></a>ES6 Object新增的Api</h5><p>-keys(obj)，获取对象的所有key形成的数组<br>-values(obj),获取对象的所有value形成的数组<br>-entries(obj)，获取对象的所有key和value形成的二维数组<br>Object.assign(dest, ···src) ,将多个src对象的值拷贝到dest中(第一层为深拷贝，第二层为浅拷贝)<br>Object.is()<br>__proto__属性<br>对象拓展运算符 (…)第一层为深拷贝，第二层为浅拷贝<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/13/ES6(%E5%9B%9B)/">博客</a></p>
<h3 id="for-in和for-of-区别"><a href="#for-in和for-of-区别" class="headerlink" title="for in和for of 区别"></a>for in和for of 区别</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>我们直接从一段代码来看</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(myArray[index]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>有哪些缺陷呢👇<br>index获取的是索引<br>遍历的顺序可能不是按照顺序进行的<br>使用for in 会遍历数组所有可枚举属性，包括原型。例如上面的method和name都会遍历</p>
<blockquote>
<p>for in 更适合遍历对象，不要使用for in去遍历数组</p>
</blockquote>
<h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-built_in">Array</span>.prototype.method=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.length);<br>&#125;<br><span class="hljs-keyword">var</span> myArray=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>myArray.name=<span class="hljs-string">&quot;数组&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> myArray) &#123;<br>  <span class="hljs-built_in">console</span>.log(value);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>for of语法遍历的是数组元素的值<br>for in 遍历的是索引</p>
<blockquote>
<p>for of遍历的只是数组内的元素(value)，而不包括数组的原型属性method和索引name</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li><p>for in 可以遍历一个普通的对象，这样也是它的本质工作，for in<strong>会遍历原型以及可枚举属性</strong>，最好的情况下，使用hasOwnProperty判断是不是实例属性。</p>
</li>
<li><p>for..of<strong>适用遍历数/数组对象/字符串/map/set等拥有迭代器对象的集合，不能遍历对象</strong>，因为没有迭代对象，与forEach()不同的是，它可以正确响应break、continue和return语句。</p>
</li>
</ol>
<h4 id="如何使用for-of-循环遍历对象-给对象添加迭代器"><a href="#如何使用for-of-循环遍历对象-给对象添加迭代器" class="headerlink" title="如何使用for of 循环遍历对象(给对象添加迭代器)"></a>如何使用for of 循环遍历对象(给对象添加迭代器)</h4><ol>
<li>类数组对象<br>如果对象是一个类数组对象，那好办，用Array.from转成数组即可。</li>
<li>非类数组对象<br>如果不是类数组对象，也有办法，添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</li>
</ol>
<p><strong>Object.keys/Object.values/Object.entries</strong></p>
<h4 id="任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"><a href="#任何数据结构只要部署-Iterator-接口，就可以完成遍历操作，即依次处理该数据结构的所有成员" class="headerlink" title="任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员"></a>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作，即依次处理该数据结构的所有成员</h4><p>迭代器对象本质上，就是一个指针对象。通过指针对象的next()，用来移动指针。</p>
<p>【迭代器协议】对象必须提供一个next()，执行该方法要么返回迭代中的下一项，要么就引起一个Stopiteration异常，以终止迭代。</p>
<p>next()返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next()。对于遍历器对象来说，done: false和value: undefined属性都是可以省略的。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性上。</p>
<h5 id="如何判断一个类型是不是可迭代对象"><a href="#如何判断一个类型是不是可迭代对象" class="headerlink" title="如何判断一个类型是不是可迭代对象"></a>如何判断一个类型是不是可迭代对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">let</span> someString = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-keyword">typeof</span> someString[<span class="hljs-built_in">Symbol</span>.iterator];          <span class="hljs-comment">// &quot;function&quot;</span><br><br></code></pre></td></tr></table></figure>

<p>常见的可迭代对象，有Array，Map, Set, String,TypeArray, arguments<br>可以通过判断Symbol.iterator判断当前变量是否是可迭代对象</p>
<h3 id="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"><a href="#forEach（数组方法）首先forEach是不能使用任何手段跳出循环的" class="headerlink" title="forEach（数组方法）首先forEach是不能使用任何手段跳出循环的"></a>forEach（数组方法）首先forEach是不能使用任何手段跳出循环的</h3><p>特性：</p>
<p>便利的时候更加简洁，效率和for循环相同，不用关心集合下标的问题，减少了出错的概率。<br>没有返回值<br>不能使用break中断循环，不能使用return返回到外层函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>实例：<br><span class="hljs-keyword">let</span> newarr=arr.forEach(<span class="hljs-function"><span class="hljs-params">i</span>=&gt;</span>&#123;<br> i+=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">//2,4,5</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">//[1,3,4]</span><br><span class="hljs-built_in">console</span>.log(newarr)<span class="hljs-comment">//undefined</span><br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>forEach() 对于空数组是不会执行回调函数的。</li>
<li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li>
<li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li>
</ol>
<h3 id="forEach-map-ES5-的区别"><a href="#forEach-map-ES5-的区别" class="headerlink" title="forEach map(ES5)的区别"></a>forEach map(ES5)的区别</h3><p>能用forEach()做到的，map()同样可以。反过来也是如此<br>map()会<strong>分配内存空间存储新数组并返回，forEach()不会返回数据。</strong><br>forEach()<strong>允许callback更改原始数组的元素</strong>。map()<strong>返回新的数组</strong>。 map() <strong>不会改变原始数组</strong>。<br>map()   forEach()   <strong>(数据为基本类型,改变其值（不会改变）)(数据为引用类型,改变其属性方法的值（会改变）)</strong><br>map() <strong>可以利用 return</strong> 语句来返回值，该值将被放入新数组中。forEach() 方法<strong>不能</strong>使用 return 语句返回值。</p>
<h4 id="map和forEach是按-（value-key）的方式遍历的"><a href="#map和forEach是按-（value-key）的方式遍历的" class="headerlink" title="map和forEach是按 （value,key）的方式遍历的"></a>map和forEach是按 （value,key）的方式遍历的</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">const  arr = [1,2,3]</span><br><span class="xml">arr.forEach((value,index)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">console.log(value,index)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml">arr.map((value,key)=&gt;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    console.log(value,key)</span><br><span class="hljs-template-variable">&#125;</span><span class="xml">)</span><br><span class="xml"><span class="hljs-comment">&lt;!-- 两个打印的结果为 --&gt;</span></span><br><span class="xml">1 0</span><br><span class="xml">2 1</span><br><span class="xml">3 2</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">mdn –forEach </a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">mdn–map</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7034350835668615199#heading-2">js学习-forEach和map是否改变原数组？</a></p>
<h2 id="基础-（已掌握）"><a href="#基础-（已掌握）" class="headerlink" title="基础 （已掌握）"></a>基础 （已掌握）</h2><h3 id="js种8种数据类型"><a href="#js种8种数据类型" class="headerlink" title="js种8种数据类型"></a>js种8种数据类型</h3><h4 id="六种基本数据类型：undefined-null-number-bollean-string"><a href="#六种基本数据类型：undefined-null-number-bollean-string" class="headerlink" title="六种基本数据类型：undefined,null,number,bollean, string"></a>六种基本数据类型：undefined,null,number,bollean, string</h4><p>还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。</p>
<blockquote>
<p>Symbol 代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p>
</blockquote>
<h4 id="另一种是复杂数据类型：Object"><a href="#另一种是复杂数据类型：Object" class="headerlink" title="另一种是复杂数据类型：Object"></a>另一种是复杂数据类型：Object</h4><p>js 可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。<br>复杂数据类型指的是 Object 类型，所有其他的如 <strong>又称为引用类型，包括 Array  Date  function</strong> 等数据类型都可以理解为 Object 类型的子类。</p>
<h4 id="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"><a href="#两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值" class="headerlink" title="两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值"></a>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值</h4><h3 id="js判断类型"><a href="#js判断类型" class="headerlink" title="js判断类型"></a>js判断类型</h3><p>判断方法：<strong>typeof()，instanceof，constructor,Object.prototype.toString.call()等</strong></p>
<h4 id="1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确"><a href="#1-typeof-其中数组、对象、null都会被判断为Object，其他判断都正确" class="headerlink" title="1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确"></a>1. typeof   其中数组、对象、null都会被判断为Object，其他判断都正确</h4><p>返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。typeof null   返回类型错误，返回object ,引用类型，除了function返回function类型外，其他均返回object。其中，null 有属于自己的数据类型 Null</p>
<h4 id="2-instanceof-只能判断引用数据类型-不能判断基本数据类型"><a href="#2-instanceof-只能判断引用数据类型-不能判断基本数据类型" class="headerlink" title="2. instanceof 只能判断引用数据类型,不能判断基本数据类型"></a>2. instanceof 只能判断引用数据类型,不能判断基本数据类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，<br><img src="/imageO/instance.jpg" srcset="/img/loading.gif" lazyload alt="instance"><br> 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。<br>instanceof <strong>只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p>
<h4 id="3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了"><a href="#3-constructor-2个作用-一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型-constructor就不能来判断数据类型了" class="headerlink" title="3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)"></a>3. constructor(2个作用 一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。需要注意的事情是如果创建一个对象来改变它的原型,constructor就不能来判断数据类型了)</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><br>　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure>
<p>constructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。<br>不过这种方法有问题：<br>1：<strong>null 和 undefined 无constructor，这种方法判断不了</strong>。<br>2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。</p>
<h4 id="4-toString-这个是最完美的"><a href="#4-toString-这个是最完美的" class="headerlink" title="4. toString 这个是最完美的"></a>4. toString 这个是最完美的</h4><p>toString() 是 Object 的原型方法，调用该方法，<strong>默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。</strong><br>对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。<strong>而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</strong></p>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在toString方法被调用时,会执行下面的操作步骤:</p>
<ol>
<li><p>获取this对象的[[Class]]属性的值.</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p>
</li>
<li><p>返回第二步的操作结果Result(2).<br>判断类型举例：</p>
</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-string">&#x27;&#x27;</span>) ;   // [<span class="hljs-keyword">object</span> String]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">1</span>) ;    // [<span class="hljs-keyword">object</span> Number]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(Symbol()); //[<span class="hljs-keyword">object</span> Symbol]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined) ; // [<span class="hljs-keyword">object</span> Undefined]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-keyword">Function</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>()) ; // [<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]) ; // [<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> RegExp()) ; // [<span class="hljs-keyword">object</span> RegExp]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Error()) ; // [<span class="hljs-keyword">object</span> Error]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(document) ; // [<span class="hljs-keyword">object</span> HTMLDocument]<br><span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">window</span>) ; //[<span class="hljs-keyword">object</span> <span class="hljs-keyword">global</span>] <span class="hljs-keyword">window</span> 是全局对象 <span class="hljs-keyword">global</span> 的引用<br></code></pre></td></tr></table></figure>

<h3 id="如何判断一个对象是数组还是对象"><a href="#如何判断一个对象是数组还是对象" class="headerlink" title="如何判断一个对象是数组还是对象"></a>如何判断一个对象是数组还是对象</h3><p>一、typeof判断数据类型（判断数组跟对象都返回object）<br>二、instanceof判断对象的原型链是否是指向构造函数的prototype</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>三、对象的constructor属性</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">　　<span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>];<br>　　console.log(arr.<span class="hljs-keyword">constructor</span> === <span class="hljs-keyword">Array</span>)<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>四、Object.prototype.toString.call(arr)<br>　　利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法，然后有人可能会问为什么不直接用arr.toString而要借用Object的方法，</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&quot;jerry&quot;));//[<span class="hljs-keyword">object</span> String]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-number">12</span>));//[<span class="hljs-keyword">object</span> Number]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">true</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Boolean</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(undefined));//[<span class="hljs-keyword">object</span> Undefined]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">null</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Null</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(&#123;<span class="hljs-type">name</span>: &quot;jerry&quot;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">function</span>()&#123;&#125;));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Function</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>([]));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Array</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>));//[<span class="hljs-keyword">object</span> <span class="hljs-type">Date</span>]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(/\d/));//[<span class="hljs-keyword">object</span> RegExp]<br>console.log(<span class="hljs-keyword">Object</span>.prototype.toString.<span class="hljs-keyword">call</span>(<span class="hljs-built_in">new</span> Person));//[<span class="hljs-keyword">object</span> <span class="hljs-keyword">Object</span>]<br></code></pre></td></tr></table></figure>

<p>直接用tostring()</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">console.log(<span class="hljs-string">&quot;jerry&quot;</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//jerry</span><br>console.log((<span class="hljs-number">1</span>).<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1</span><br>console.log(<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2</span><br>console.log(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//Wed Dec 21 2016 20:35:48 GMT+0800 (中国标准时间)</span><br>console.log(<span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//function ()&#123;&#125;</span><br>console.log(null.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br>console.log(undefined.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure>

<h4 id="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"><a href="#因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法" class="headerlink" title="因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法"></a>因为toString为Object原型上的方法，而Array、Function都是Object的实例，实例重新改写了原型上的toString方法，不同的对象调用toString方法，调用的是改写之后的方法</h4><p>（转成各种类型的字符串），而不会调用Object原型上的toString()方法，因此直接调用不能判断对象类型</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var arr=<span class="hljs-literal">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]</span>;<br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//true</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//1,2,3</span><br>delete <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.toString;<span class="hljs-comment">//delete操作符可以删除实例属性</span><br>console.log(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>prototype.has<span class="hljs-constructor">OwnProperty(<span class="hljs-string">&quot;toString&quot;</span>)</span>);<span class="hljs-comment">//false</span><br>console.log(arr.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<span class="hljs-comment">//&quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure>

<p>　我们可以看到，删除实例上的toString方法后调用的是Object原型上的toString()方法，返回对象类型</p>
<p>五、es6的方法——Array.isArray()</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">　　<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array([])</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure>

<p>六、看好多博客说用length判断，这个其实不准确</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> obj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">1</span>&#125;<br><span class="hljs-selector-tag">var</span> arr = <span class="hljs-selector-attr">[]</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//undefined</span><br>console<span class="hljs-selector-class">.log</span>(arr.length)<span class="hljs-comment">//0</span><br><br>obj<span class="hljs-selector-class">.length</span> = <span class="hljs-number">1</span><br>console<span class="hljs-selector-class">.log</span>(obj.length)<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure>
<p>对象可以直接添加length这个属性，就无法区分了</p>
<h3 id="暂停死区"><a href="#暂停死区" class="headerlink" title="暂停死区"></a>暂停死区</h3><p>在代码块内，使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”</p>
<h2 id="较陌生不常问-需掌握"><a href="#较陌生不常问-需掌握" class="headerlink" title="较陌生不常问(需掌握)"></a>较陌生不常问(需掌握)</h2><h3 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h3><h5 id="js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度"><a href="#js-延迟加载，也就是等页面加载完成之后再加载-JavaScript-文件。-js-延迟加载有助于提高页面加载速度" class="headerlink" title="js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度"></a>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度</h5><p>一般有以下几种方式：(defer 属性async 属性动态创建 DOM 方式使用 setTimeout 延迟方法  让 JS 最后加载)</p>
<p>js 的<strong>加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载</strong>，提高页面的渲染速度。<br>我了解到的几种方式是：</p>
<ol>
<li><p>第一种方式是我们一般采用的是将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</p>
</li>
<li><p>第二种方式是给 js 脚本添加 defer 属性，<strong>这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，</strong>这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</p>
</li>
<li><p>第三种方式是给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是<strong>当脚本加载完成后立即执行 js 脚本</strong>，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</p>
</li>
<li><p>第四种方式是动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</p>
</li>
</ol>
<h3 id="0-1-0-2为什么不等于0-3？"><a href="#0-1-0-2为什么不等于0-3？" class="headerlink" title="0.1+0.2为什么不等于0.3？"></a>0.1+0.2为什么不等于0.3？</h3><p>当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在<strong>计算机里所存储的二进制</strong>，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 <strong>64 位双精度格式</strong>来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉这样就造成了精度丢失的问题。这是第一个会造成精度丢失的地方。在对两个以 64 位双精度格式的数据进行计算的时候，首先会进行对阶的处理，对阶指的是将阶码对齐，也就是将小数点的位置对齐后，再进行计算，一般是小阶向大阶对齐，因此小阶的数在对齐的过程中，有效数字会向右移动，移动后超过有效位数的位会被截取掉，这是第二个可能会出现精度丢失的地方。当两个数据阶码对齐后，进行相加运算后，得到的结果可能会超过 53 位有效数字，因此超过的位数也会被截取掉，这是可能发生精度丢失的第三个地方。</p>
<p>对于这样的情况，<strong>我们可以将其转换为整数后再进行运算，运算后再转换为对应的小数</strong>，以这种方式来解决这个问题。<br>(<strong>toPrecision vs toFixed</strong> –toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。<br>–toFixed 是小数点后指定位数取整，从小数点开始数起。)</p>
<p>我们还可以将两个数相加的结果和右边相减，如果相减的结果小于一个极小数，那么我们就可以认定结果是相等的，这个极小数可以<br>使用 es6 的 Number.EPSILON</p>
<h3 id="Node-环境中的事件环（Event-Loop"><a href="#Node-环境中的事件环（Event-Loop" class="headerlink" title="Node 环境中的事件环（Event Loop)"></a>Node 环境中的事件环（Event Loop)</h3><p>Node是基于V8引擎的运行在服务端的JavaScript运行环境，在处理高并发、I/O密集(文件操作、网络操作、数据库操作等)场景有明显的优势。虽然用到也是V8引擎，但由于服务目的和环境不同，导致了它的API与原生JS有些区别，其Event Loop还要处理一些I/O，比如新的网络连接等，所以Node的Event Loop(事件环机制)与浏览器的是不太一样。<br> 执行顺序如下：</p>
<p><img src="/imageO/Node.jpg" srcset="/img/loading.gif" lazyload alt="Node"></p>
<p>timers: 计时器，执行setTimeout和setInterval的回调<br>pending callbacks: 执行延迟到下一个循环迭代的 I/O 回调<br>idle, prepare: 队列的移动，仅系统内部使用<br>poll轮询: 检索新的 I/O 事件;执行与 I/O 相关的回调。事实上除了其他几个阶段处理的事情，其他几乎所有的异步都在这个阶段处理。<br>check: 执行setImmediate回调，setImmediate在这里执行<br>close callbacks: 执行close事件的callback，一些关闭的回调函数，如：socket.on(‘close’, …)</p>
<h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>相关知识点：</p>
<p>1.意外的全局变量<br>2.被遗忘的计时器或回调函数<br>3.脱离 DOM 的引用<br>4.闭包</p>
<p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p>
<p>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留<br>在内存中，而无法被回收。</p>
<p>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回<br>收。</p>
<p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域==&gt;当前创建函数所处的上下文。如果是在全局下创建的函数就是[[scope]]:EC(G)，函数执行的时候，形成一个全新的私有上下文EC(FN)，供字符串代码执行(进栈执行)<br>定义：简单来说作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成<br>1.全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</p>
<p>2.函数作用域：在固定的代码片段才能被访问</p>
<p>作用：作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<br>作用域链参考链接一般情况下，变量到 创建该变量 的函数的作用域中取值。但是如果在当前作用域中没有查到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7016593221815910408#heading-43">掘金</a></p>
<h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><p>DOM 指的是<strong>文档对象模型，它指的是把文档当做一个对象来对待，</strong>这个对象主要定义了处理网页内容的方法和接口。</p>
<p>BOM 指的是<strong>浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</strong><br>BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。<strong>window 对象含有 location 对象、navigator 对象、screen 对象等子对象，</strong>并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。<br><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2021/04/06/Javascript%E5%85%A5%E9%97%A8(%E4%BA%94)/#%E6%93%8D%E4%BD%9CBOM%E5%AF%B9%E8%B1%A1-%E9%87%8D%E7%82%B9">博客：</a></p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>事件会从最内层的元素开始发生，一直向上传播，直到document对象。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;<br>    &lt;p <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;Click <span class="hljs-keyword">me</span>!&lt;/p&gt;<br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">p</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> document<br></code></pre></td></tr></table></figure>

<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。<br>上面的例子在事件捕获的概念下发生click事件的顺序应该是</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">document</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">html</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">body</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">div</span> -&gt;</span> p<br></code></pre></td></tr></table></figure>

<h3 id="addEventListener-事件-捕获和冒泡（应用场景：事件委托）"><a href="#addEventListener-事件-捕获和冒泡（应用场景：事件委托）" class="headerlink" title="addEventListener  事件 捕获和冒泡（应用场景：事件委托）"></a>addEventListener  事件 捕获和冒泡（应用场景：事件委托）</h3><p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">element.add<span class="hljs-constructor">EventListener(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>, <span class="hljs-params">useCapture</span>)</span><br></code></pre></td></tr></table></figure>

<p>重点来看看第三个参数useCapture</p>
<p>true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）<br>false- <strong>false- 默认。</strong>事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）</p>
<p>所以我们通常来说，<strong>默认第三个参数不写的话，是按照事件句柄在冒泡执行的。</strong></p>
<h4 id="attachEvent-兼容IE的写法"><a href="#attachEvent-兼容IE的写法" class="headerlink" title="attachEvent (兼容IE的写法)"></a>attachEvent (兼容IE的写法)</h4><p>默认是事件冒泡阶段调用处理函数，写事件名时候要加上”on”前缀（”onload”、”onclick”等）。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">object</span>.attach<span class="hljs-constructor">Event(<span class="hljs-params">event</span>, <span class="hljs-params">function</span>)</span><br></code></pre></td></tr></table></figure>

<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>利用事件流的特性，我们可以使用一种叫做事件代理的方法，其实利用的就是事件冒泡的机制。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span>下面的内容是子元素1<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素2<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        下面的内容是子元素3<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>li内容&gt;&gt;&gt; <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 这是span内容123<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>js代码</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">xxx.addEventListener(&#x27;click&#x27;, function (<span class="hljs-built_in">e</span>) &#123;<br>            console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>,<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.tagName.toLowerCase() === &#x27;li&#x27;) &#123;<br>                console.<span class="hljs-built_in">log</span>(&#x27;打印&#x27;)<br>            &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>更加规范的写法👇</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delegate</span><span class="hljs-params">(element, eventType, selector, fn)</span> &#123;</span><br>          element.addEventListener(eventType, <span class="hljs-keyword">e</span> =&gt; &#123;<br>              <span class="hljs-keyword">let</span> <span class="hljs-keyword">el</span> = <span class="hljs-keyword">e</span>.target<br>              <span class="hljs-keyword">while</span> (!el.matches(selector)) &#123;<br>                  <span class="hljs-keyword">if</span> (element === <span class="hljs-keyword">el</span>) &#123;<br>                      <span class="hljs-keyword">el</span> = null<br>                      <span class="hljs-keyword">break</span><br>                  &#125;<br>                  <span class="hljs-keyword">el</span> = <span class="hljs-keyword">el</span>.parentNode<br>              &#125;<br>              <span class="hljs-keyword">el</span> &amp;&amp; fn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">el</span>, <span class="hljs-keyword">e</span>, <span class="hljs-keyword">el</span>)<br>          &#125;,true)<br>          <span class="hljs-keyword">return</span> element<br>      &#125;<br></code></pre></td></tr></table></figure>

<h4 id="事件委托如何获取哪个子节点触发的函数"><a href="#事件委托如何获取哪个子节点触发的函数" class="headerlink" title="事件委托如何获取哪个子节点触发的函数"></a>事件委托如何获取哪个子节点触发的函数</h4><p>事件委托所有子元素都会触发点击事件，所以给需要监听的元素设置一个相同的类名或者相同的标签，先判断点击的元素是否为需要触发事件的标签。然后再进行相应的判断</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stan">ul.onclick = (<span class="hljs-built_in">e</span>) =&gt; &#123;<br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.innerHTML)<span class="hljs-comment">//目标的文本</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.tagName)<span class="hljs-comment">//目标的标签名</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.nodeName)<span class="hljs-comment">//目标的节点名</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.id)<span class="hljs-comment">//目标的id（标签不设置为空）</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.className<span class="hljs-comment">//目标的类名（标签不设置为空）)</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.childNode<span class="hljs-comment">//目标的子节点</span><br>      console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">e</span>.<span class="hljs-built_in">target</span>.parentNode)<span class="hljs-comment">//目标的父节点</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="阻止事件冒泡和默认事件-event-preventDefault-阻止默认事件-amp-amp-event-stopPropagation-阻止冒泡"><a href="#阻止事件冒泡和默认事件-event-preventDefault-阻止默认事件-amp-amp-event-stopPropagation-阻止冒泡" class="headerlink" title="阻止事件冒泡和默认事件(event.preventDefault()   // 阻止默认事件&amp;&amp;event.stopPropagation() //阻止冒泡)"></a>阻止事件冒泡和默认事件(event.preventDefault()   // 阻止默认事件&amp;&amp;event.stopPropagation() //阻止冒泡)</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6864398060702760968#heading-19">天天文章</a></p>
<h3 id="全局主题切换如何实现"><a href="#全局主题切换如何实现" class="headerlink" title="全局主题切换如何实现"></a>全局主题切换如何实现</h3><p>几种方法<br>基于css变量实现，高效快捷。<br>动态切换根元素样式名或ID。<br>element官方动态主题色 + 动态切换文件（要兼容IE低版本，最终决定使用此方法）<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6898958088301182983">掘金</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7053031139694346248#heading-3">三步实现主题切换</a></p>
<h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出<br>数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>typeof NaN; <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;number&quot;</span><br><br></code></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是<strong>唯一一个非自反</strong>（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。</p>
<h3 id="null是对象吗？为什么？"><a href="#null是对象吗？为什么？" class="headerlink" title="null是对象吗？为什么？"></a>null是对象吗？为什么？</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>typeof 运算符对基本数据类型的运算：<br>typeof <span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;string&#x27;</span><br>typeof NaN <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;number&#x27;</span><br>typeof true <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;boolean&#x27;</span><br>typeof undefined <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;undefined&#x27;</span><br>typeof Symbol() <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;symbol&#x27;</span><br>typeof null <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;object&#x27;</span><br><br></code></pre></td></tr></table></figure>

<p>结论: null不是对象。</p>
<p>解释: 虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。<br>在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存</p>
<h3 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6912298148098473998#comment">null和undefined的区别（简单易懂）</a><br>null==undefined结果为true<br>null===undefined结果为false</p>
<h3 id="事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#事件是什么？IE-与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？"></a>事件是什么？IE 与火狐的事件机制有什么区别？ 如何阻止冒泡？</h3><p>1.<strong>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。</strong>事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。<br>2.事件处理机制：IE 支持事件冒泡、Firefox 同时支持两种事件模型，也就是：事件冒泡和事件捕获。<br>3.event.stopPropagation() 或者 ie 下的方法 event.cancelBubble = true;</p>
<p>详细资料可以参考：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvdabao/p/3265870.html">《Javascript 事件模型系列（一）事件及事件的三种模型》</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuseyukui/article/details/13771493">《Javascript 事件模型：事件捕获和事件冒泡》</a></p>
<h3 id="操作符的作用？-x-大致等同于-x-1"><a href="#操作符的作用？-x-大致等同于-x-1" class="headerlink" title="~ 操作符的作用？~x 大致等同于 -(x+1)"></a>~ 操作符的作用？~x 大致等同于 -(x+1)</h3><p>~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。</p>
<h3 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h3><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p>
<p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p>
<h3 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h3><p>mouseover：当鼠标移入元素或其子元素都会触发事件，<strong>所以有一个重复触发，冒泡的过程</strong>。对应的移除事件是mouseout<br>mouseenter：<strong>当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡</strong>，对应的移除事件是mouseleave</p>
<h3 id="去除字符串首尾空格"><a href="#去除字符串首尾空格" class="headerlink" title="去除字符串首尾空格"></a>去除字符串首尾空格</h3><ol>
<li>使用正则(^\s*)|(\s*$)即可</li>
<li>使用jquery</li>
</ol>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel"><br>$.<span class="hljs-keyword">trim</span>(str)<br><br></code></pre></td></tr></table></figure>

<h3 id="比较运算符！！！重要"><a href="#比较运算符！！！重要" class="headerlink" title="比较运算符！！！重要"></a>比较运算符！！！重要</h3><p>=    赋值<br>==   等于(类型不一样，值一样，也会判断为true)<br>===   绝对等于 (类型一样，值一样，结果为true)</p>
<h4 id="Object-is-使用过吗？跟-和-区别"><a href="#Object-is-使用过吗？跟-和-区别" class="headerlink" title="Object.is()使用过吗？跟 === 和 == 区别"></a>Object.is()使用过吗？跟 === 和 == 区别</h4><p>两等号判等，会在比较时进行类型转换。<br>三等号判等（判断严格），比较时不进行隐式类型转换，（类型不同则会返回false）<br>使用 Object.is 来进行相等判断时，<strong>一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 认定为是相等的。</strong></p>
<h2 id="其他不常见"><a href="#其他不常见" class="headerlink" title="其他不常见"></a>其他不常见</h2><h3 id="js如何将json字符串转换为json对象-SON-是轻量级的文本数据交换格式"><a href="#js如何将json字符串转换为json对象-SON-是轻量级的文本数据交换格式" class="headerlink" title="js如何将json字符串转换为json对象(SON 是轻量级的文本数据交换格式)"></a>js如何将json字符串转换为json对象(SON 是轻量级的文本数据交换格式)</h3><p>JSON字符串:<br>var str1 = ‘{ “name”: “cxh”, “sex”: “man” }’;<br>JSON对象:<br>var str2 = { “name”: “cxh”, “sex”: “man” };</p>
<h4 id="一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）"><a href="#一、JSON字符串转换为JSON对象-（eval-函数-amp-amp-parseJSON-amp-amp-parse）" class="headerlink" title="一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）"></a>一、JSON字符串转换为JSON对象 （eval(()函数 &amp;&amp;parseJSON &amp;&amp; parse）</h4><h5 id="二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串"><a href="#二、可以使用toJSONString-或者全局方法JSON-stringify-将JSON对象转化为JSON字符串" class="headerlink" title="二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串"></a>二、可以使用toJSONString()或者全局方法JSON.stringify()将JSON对象转化为JSON字符串</h5><p>例如：</p>
<p>var last=obj.toJSONString(); //将JSON对象转化为JSON字符<br>或者</p>
<p>var last=JSON.stringify(obj); //将JSON对象转化为JSON字符</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/138712665">js如何将json字符串转换为json对象</a></p>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="number与string的转换-面试题"><a href="#number与string的转换-面试题" class="headerlink" title="number与string的转换(面试题)"></a>number与string的转换(面试题)</h4><h5 id="number-gt-string"><a href="#number-gt-string" class="headerlink" title="number -&gt; string"></a>number -&gt; string</h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs q"><br><span class="hljs-comment">// toString()</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num.toString();<br>alert(typeof (num));<br>alert(typeof (res));<br>*/<br><br><span class="hljs-comment">// 加一个空格</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = num + <span class="hljs-string">&quot;&quot;</span><br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 使用String(数字)函数</span><br>/*<br><span class="hljs-built_in">var</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">var</span> res = String(num);<br>alert(num + <span class="hljs-string">&quot;, &quot;</span> + typeof (num));<br>alert(res + <span class="hljs-string">&quot;, &quot;</span> + typeof (res));<br>*/<br><br><span class="hljs-comment">// 没有固定精度的表示</span><br>/*<br><span class="hljs-built_in">var</span> n = <span class="hljs-number">1234.56789</span>;<br><span class="hljs-built_in">var</span> s4 = n.toFixed(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">var</span> s5 = n.toExponential(<span class="hljs-number">2</span>); <span class="hljs-comment">// 指数表示</span><br><span class="hljs-built_in">var</span> s6 = n.toPrecision(<span class="hljs-number">2</span>); <span class="hljs-comment">// 有效位数</span><br><br>alert(s4 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s4));<br>alert(s5 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s5));<br>alert(s6 + <span class="hljs-string">&quot;, &quot;</span> + typeof(s6));<br>*/<br><br></code></pre></td></tr></table></figure>

<h5 id="string-gt-number"><a href="#string-gt-number" class="headerlink" title="string -&gt; number"></a>string -&gt; number</h5><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs q"><br><span class="hljs-comment">// 做除了加法以外的数字运算</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;12345&quot;</span>;<br><span class="hljs-built_in">var</span> r = s / <span class="hljs-number">1</span>; <span class="hljs-comment">// s - 0;</span><br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><br><span class="hljs-comment">// 使用parse系方法</span><br><span class="hljs-comment">// parseInt() parseFloat()</span><br>/*<br><span class="hljs-built_in">var</span> s = <span class="hljs-string">&quot;08&quot;</span>;<br><span class="hljs-built_in">var</span> r = parseInt(s);<br>alert(s + <span class="hljs-string">&quot;, &quot;</span> + typeof s);<br>alert(r + <span class="hljs-string">&quot;, &quot;</span> + typeof r);<br>*/<br><span class="hljs-comment">// parse系方法，只识别一个字符串中开始的数字，如果识别不了就返回NaN</span><br>alert(parseInt(<span class="hljs-string">&quot;a123abc&quot;</span>) + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 使用Number()函数</span><br><br></code></pre></td></tr></table></figure>

<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p><a target="_blank" rel="noopener" href="https://pengzhenglong.github.io/2022/03/11/Js%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/">博客</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
                    
                      <a class="hover-with-bg" href="/tags/JS/">JS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/07/%5B%E6%80%BB%E7%BB%93%5D%E8%AE%A1%E7%BD%91+%E6%B5%8F%E8%A7%88%E5%99%A8+http+%E5%AE%89%E5%85%A8%E9%9D%A2%E8%AF%95%E9%A2%98/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计网+HTTP+浏览器+网络安全面试题总结</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/04/javaScript%E4%B9%8BMath%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/">
                        <span class="hidden-mobile">javaScript之Math常用方法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
