

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/2.jpg">
  <link rel="icon" href="/img/2.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="DragonPeng">
  <meta name="keywords" content="">
  
  <title>大文件上传以及断点续传(项目) - DragonPeng的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.9","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>DragonPeng' blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/page1.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="大文件上传以及断点续传(项目)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-28 21:15" pubdate>
        March 28, 2022 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      116
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">大文件上传以及断点续传(项目)</h1>
            
            <div class="markdown-body">
              <hr>
<h3 id="xxxxx导入财务以及销售报表–大文件上传以及断点续传"><a href="#xxxxx导入财务以及销售报表–大文件上传以及断点续传" class="headerlink" title="xxxxx导入财务以及销售报表–大文件上传以及断点续传"></a>xxxxx导入财务以及销售报表–大文件上传以及断点续传</h3><h2 id="字节跳动面试官：请你实现一个大文件上传和断点续传"><a href="#字节跳动面试官：请你实现一个大文件上传和断点续传" class="headerlink" title="字节跳动面试官：请你实现一个大文件上传和断点续传"></a>字节跳动面试官：请你实现一个大文件上传和断点续传</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">前端：<span class="hljs-symbol">Vue@</span><span class="hljs-number">2</span> + Element-ui<br><br>服务端：<span class="hljs-symbol">Nodejs@</span><span class="hljs-number">14</span> + multiparty<br></code></pre></td></tr></table></figure>
<h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><h4 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 <strong>Blob.prototype.slice</strong> 方法，和数组的 <code>slice</code> 方法相似，文件的 <code>slice</code> 方法可以返回原文件的某个切</p>
<p>预先定义好单个切片大小，将文件切分为一个个切片，然后<strong>借助 http 的可并发性，同时上传多个切片</strong>。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间</p>
<p>另外由于是<strong>并发</strong>，传输到服务端的顺序可能会发生变化，<strong>因此我们还需要给每个切片记录顺序</strong></p>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>服务端负责接受前端传输的切片，并在接收到所有切片后<strong>合并</strong>所有切片</p>
<p>这里又引伸出两个问题</p>
<p>何时合并切片，即切片什么时候传输完成<br>如何合并切片<br>第一个问题需要前端配合，前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。或者也可以额外发一个请求，主动通知服务端进行切片的合并</p>
<p>第二个问题，具体如何合并切片呢？这里可以使用 Nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里talk is cheap,show me the code，接着我们用代码实现上面的思路</p>
<h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>前端使用 Vue 作为开发框架，对界面没有太大要求，原生也可以，考虑到美观使用 Element-ui 作为 UI 框架</p>
<h4 id="上传控件"><a href="#上传控件" class="headerlink" title="上传控件"></a>上传控件</h4><p>首先创建选择文件的控件并监听 change 事件，另外就是上传按钮</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>upload<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">     <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params">e</span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> [file] = e.target.files;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (!file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">      <span class="hljs-built_in">Object</span>.assign(<span class="hljs-built_in">this</span>.$data, <span class="hljs-built_in">this</span>.$options.data());</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.container.file = file;</span><br>    &#125;,<br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;&#125;</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h4 id="请求逻辑"><a href="#请求逻辑" class="headerlink" title="请求逻辑"></a>请求逻辑</h4><p>考虑到通用性，这里没有用第三方的请求库，而是用原生 XMLHttpRequest 做一层简单的封装来发请求</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>      requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="上传切片"><a href="#上传切片" class="headerlink" title="上传切片"></a>上传切片</h3><p>接着实现比较重要的上传功能，上传需要做两件事</p>
<ol>
<li>对文件进行切片</li>
<li>将切片传输给服务端<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">+ <span class="hljs-comment">// 切片大小</span></span><br><span class="javascript">+ <span class="hljs-comment">// the chunk size</span></span><br><span class="javascript">+ <span class="hljs-keyword">const</span> SIZE = <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>; </span><br>​<br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;，<br>+   data: []<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">+    <span class="hljs-comment">// 生成文件切片</span></span><br><span class="javascript">+    <span class="hljs-function"><span class="hljs-title">createFileChunk</span>(<span class="hljs-params">file, size = SIZE</span>)</span> &#123;</span><br><span class="javascript">+     <span class="hljs-keyword">const</span> fileChunkList = [];</span><br><span class="javascript">+      <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;</span><br><span class="javascript">+      <span class="hljs-keyword">while</span> (cur &lt; file.size) &#123;</span><br>+        fileChunkList.push(&#123; file: file.slice(cur, cur + size) &#125;);<br>+        cur += size;<br>+      &#125;<br><span class="javascript">+      <span class="hljs-keyword">return</span> fileChunkList;</span><br>+    &#125;,<br><span class="javascript">+   <span class="hljs-comment">// 上传切片</span></span><br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data</span><br><span class="javascript">+        .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk，hash &#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">+          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);</span><br><span class="javascript">+          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);</span><br><span class="javascript">+          <span class="hljs-keyword">return</span> &#123; formData &#125;;</span><br>+        &#125;)<br><span class="javascript">+        .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData &#125;</span>) =&gt;</span></span><br><span class="javascript">+          <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">+            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,</span><br>+            data: formData<br>+          &#125;)<br>+        );<br><span class="javascript">+      <span class="hljs-comment">// 并发请求</span></span><br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList); </span><br>+    &#125;,<br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.container.file) <span class="hljs-keyword">return</span>;</span><br><span class="javascript">+      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-built_in">this</span>.createFileChunk(<span class="hljs-built_in">this</span>.container.file);</span><br><span class="javascript">+      <span class="hljs-built_in">this</span>.data = fileChunkList.map(<span class="hljs-function">(<span class="hljs-params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;</span><br>+        chunk: file,<br><span class="javascript">+        <span class="hljs-comment">// 文件名 + 数组下标</span></span><br><span class="javascript">+        hash: <span class="hljs-built_in">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index</span><br>+      &#125;));<br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uploadChunks();</span><br>+    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
当点击上传按钮时，调用 <strong>createFileChunk</strong> 将文件切片，切片数量通过文件大小控制，这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片</li>
</ol>
<p>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <strong>fileChunkList</strong> 数组中返回</p>
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<strong>文件名 + 下标</strong>，这样后端可以知道当前切片是第几个切片，用于之后的合并切片</p>
<p>随后调用 <strong>uploadChunks</strong> 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 <strong>request</strong> 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p>
<h3 id="发送合并请求"><a href="#发送合并请求" class="headerlink" title="发送合并请求"></a>发送合并请求</h3><p>使用整体思路中提到的第二种合并切片的方式，即前端主动通知服务端进行合并</p>
<p>前端发送额外的合并请求，服务端接受到请求时合并切片</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;</span>upload<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>​<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data: <span class="hljs-function">() =&gt;</span> (&#123;</span><br>    container: &#123;<br><span class="javascript">      file: <span class="hljs-literal">null</span></span><br>    &#125;,<br>    data: []<br>  &#125;),<br>  methods: &#123;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">handleFileChange</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">createFileChunk</span>(<span class="hljs-params"></span>)</span> &#123;&#125;,</span><br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data</span><br><span class="javascript">        .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk，hash &#125;</span>) =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);</span><br><span class="javascript">          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);</span><br><span class="javascript">          <span class="hljs-keyword">return</span> &#123; formData &#125;;</span><br>        &#125;)<br><span class="javascript">        .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData &#125;</span>) =&gt;</span></span><br><span class="javascript">          <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,</span><br>            data: formData<br>          &#125;)<br>        );<br><span class="javascript">      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList);</span><br><span class="javascript">+     <span class="hljs-comment">// 合并切片</span></span><br><span class="javascript">+     <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.mergeRequest();</span><br>    &#125;,<br><span class="javascript">+    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mergeRequest</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">+      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.request(&#123;</span><br><span class="javascript">+        url: <span class="hljs-string">&quot;http://localhost:3000/merge&quot;</span>,</span><br>+        headers: &#123;<br><span class="javascript">+          <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span></span><br>+        &#125;,<br><span class="javascript">+        data: <span class="hljs-built_in">JSON</span>.stringify(&#123;</span><br><span class="javascript">+          filename: <span class="hljs-built_in">this</span>.container.file.name</span><br>+        &#125;)<br>+      &#125;);<br>+    &#125;,    <br><span class="javascript">    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;&#125;</span><br>  &#125;<br>&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>


<h3 id="服务端部分"><a href="#服务端部分" class="headerlink" title="服务端部分"></a>服务端部分</h3><p>使用 http 模块搭建一个简单服务端</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> server = http.createServer();<br>​<br>server.<span class="hljs-literal">on</span>(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>
<h4 id="接受切片"><a href="#接受切片" class="headerlink" title="接受切片"></a>接受切片</h4><p>使用 multiparty 处理前端传来的 formData</p>
<p>在 multiparty.parse 的回调中，files 参数保存了 formData 中文件，fields 参数保存了 formData 中非文件的字段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br>+ <span class="hljs-keyword">const</span> fse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);<br>+ <span class="hljs-keyword">const</span> multiparty = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;multiparty&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> server = http.createServer();<br>+ <span class="hljs-comment">// 大文件存储目录</span><br>+ <span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>​<br>+  <span class="hljs-keyword">const</span> multipart = <span class="hljs-keyword">new</span> multiparty.Form();<br>​<br>+  multipart.parse(req, <span class="hljs-keyword">async</span> (err, fields, files) =&gt; &#123;<br>+    <span class="hljs-keyword">if</span> (err) &#123;<br>+      <span class="hljs-keyword">return</span>;<br>+    &#125;<br>+    <span class="hljs-keyword">const</span> [chunk] = files.chunk;<br>+    <span class="hljs-keyword">const</span> [hash] = fields.hash;<br>+    <span class="hljs-keyword">const</span> [filename] = fields.filename;<br>+    <span class="hljs-comment">// 创建临时文件夹用于临时存储 chunk</span><br>+    <span class="hljs-comment">// 添加 chunkDir 前缀与文件名做区分</span><br>+    <span class="hljs-keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, <span class="hljs-string">&#x27;chunkDir&#x27;</span> + filename);<br>​<br>+    <span class="hljs-keyword">if</span> (!fse.existsSync(chunkDir)) &#123;<br>+      <span class="hljs-keyword">await</span> fse.mkdirs(chunkDir);<br>+    &#125;<br>​<br>+    <span class="hljs-comment">// fs-extra 的 rename 方法 windows 平台会有权限问题</span><br>+    <span class="hljs-comment">// @see https://github.com/meteor/meteor/issues/7852#issuecomment-255767835</span><br>+    <span class="hljs-keyword">await</span> fse.move(chunk.path, <span class="hljs-string">`<span class="hljs-subst">$&#123;chunkDir&#125;</span>/<span class="hljs-subst">$&#123;hash&#125;</span>`</span>);<br>+    res.end(<span class="hljs-string">&quot;received file chunk&quot;</span>);<br>+  &#125;);<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>查看 multiparty 处理后的 chunk 对象，path 是存储临时文件的路径，size 是临时文件大小，在 multiparty 文档中提到可以使用 fs.rename（这里换成了 fs.remove, 因为 fs-extra 的 rename 方法在 windows 平台存在权限问题）</p>
<p>在接受文件切片时，需要先创建临时存储切片的文件夹，以 chunkDir 作为前缀，文件名作为后缀</p>
<p>由于前端在发送每个切片时额外携带了唯一值 hash，所以以 hash 作为文件名，将切片从临时路径移动切片文件夹中，最后的结果如下</p>
<h4 id="合并切片"><a href="#合并切片" class="headerlink" title="合并切片"></a>合并切片</h4><p>在接收到前端发送的合并请求后，服务端将文件夹下的所有切片进行合并</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);<br><span class="hljs-keyword">const</span> fse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs-extra&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> server = http.createServer();<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br>+ <span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>+   <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+     <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>+     req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>+       chunk += data;<br>+     &#125;);<br>+     req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>+       resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>+     &#125;);<br>+   &#125;);<br>​<br>+ <span class="hljs-comment">// 写入文件流</span><br>+ <span class="hljs-keyword">const</span> pipeStream = <span class="hljs-function">(<span class="hljs-params">path, writeStream</span>) =&gt;</span><br>+  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>+    <span class="hljs-keyword">const</span> readStream = fse.createReadStream(path);<br>+    readStream.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>+      fse.unlinkSync(path);<br>+      resolve();<br>+    &#125;);<br>+    readStream.pipe(writeStream);<br>+  &#125;);<br>​<br><span class="hljs-comment">// 合并切片</span><br>+ <span class="hljs-keyword">const</span> mergeFileChunk = <span class="hljs-keyword">async</span> (filePath, filename, size) =&gt; &#123;<br>+   <span class="hljs-keyword">const</span> chunkDir = path.resolve(UPLOAD_DIR, <span class="hljs-string">&#x27;chunkDir&#x27;</span> + filename);<br>+   <span class="hljs-keyword">const</span> chunkPaths = <span class="hljs-keyword">await</span> fse.readdir(chunkDir);<br>+   <span class="hljs-comment">// 根据切片下标进行排序</span><br>+   <span class="hljs-comment">// 否则直接读取目录的获得的顺序会错乱</span><br>+   chunkPaths.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>] - b.split(<span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">1</span>]);<br>+   <span class="hljs-comment">// 并发写入文件</span><br>+   <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>+     chunkPaths.map(<span class="hljs-function">(<span class="hljs-params">chunkPath, index</span>) =&gt;</span><br>+       pipeStream(<br>+         path.resolve(chunkDir, chunkPath),<br>+         <span class="hljs-comment">// 根据 size 在指定位置创建可写流</span><br>+         fse.createWriteStream(filePath, &#123;<br>+           start: index * size,<br>+         &#125;)<br>+       )<br>+     )<br>+  );<br>+  <span class="hljs-comment">// 合并后删除保存切片的目录</span><br>+  fse.rmdirSync(chunkDir);<br>+&#125;;<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>  <span class="hljs-keyword">if</span> (req.method === <span class="hljs-string">&quot;OPTIONS&quot;</span>) &#123;<br>    res.status = <span class="hljs-number">200</span>;<br>    res.end();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>​<br>+   <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/merge&quot;</span>) &#123;<br>+     <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>+     <span class="hljs-keyword">const</span> &#123; filename,size &#125; = data;<br>+     <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;filename&#125;</span>`</span>);<br>+     <span class="hljs-keyword">await</span> mergeFileChunk(filePath, filename);<br>+     res.end(<br>+       <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+         code: <span class="hljs-number">0</span>,<br>+         message: <span class="hljs-string">&quot;file merged success&quot;</span><br>+       &#125;)<br>+     );<br>+   &#125;<br>​<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>由于前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹</p>
<p>接着使用 fs.createWriteStream 创建一个可写流，可写流文件名就是上传时的文件名</p>
<p>随后遍历整个切片文件夹，将切片通过 fs.createReadStream 创建可读流，传输合并到目标文件中</p>
<p>值得注意的是每次可读流都会传输到可写流的指定位置，这是通过 createWriteStream 的第二个参数 start 控制的，目的是能够并发合并多个可读流至可写流中，这样即使并发时流的顺序不同，也能传输到正确的位置</p>
<p>所以还需要让前端在请求的时候提供之前设定好的 size 给服务端，服务端根据 size 指定可读流的起始位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">mergeRequest</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.request(&#123;<br>        url: <span class="hljs-string">&quot;http://localhost:3000/merge&quot;</span>,<br>        headers: &#123;<br>          <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>        &#125;,<br>        data: <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+         size: SIZE,<br>          filename: <span class="hljs-built_in">this</span>.container.file.name<br>        &#125;)<br>      &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure>
<p>其实也可以等上一个切片合并完后再合并下个切片，这样就不需要指定位置，但传输速度会降低，所以使用了并发合并的手段</p>
<p>接着只要保证每次合并完成后删除这个切片，等所有切片都合并完毕后最后删除切片文件夹即可</p>
<h4 id="显示上传进度条"><a href="#显示上传进度条" class="headerlink" title="显示上传进度条"></a>显示上传进度条</h4><p>上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现单个切片的进度条</p>
<p>单个切片进度条<br>XMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// xhr</span><br>    request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>+     onProgress = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e,<br>      requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>+       xhr.upload.onprogress = onProgress;<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>由于每个切片都需要触发独立的监听事件，所以需要一个工厂函数，根据传入的切片返回不同的监听函数</p>
<p>在原先的前端上传逻辑中新增监听函数部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    <span class="hljs-comment">// 上传切片，同时过滤已上传的切片</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">uploadChunks</span>(<span class="hljs-params">uploadedList = []</span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> requestList = <span class="hljs-built_in">this</span>.data<br>+       .map(<span class="hljs-function">(<span class="hljs-params">&#123; chunk,hash,index &#125;</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();<br>          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);<br>          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);<br>          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">this</span>.container.file.name);<br>+         <span class="hljs-keyword">return</span> &#123; formData,index &#125;;<br>        &#125;)<br>+       .map(<span class="hljs-function">(<span class="hljs-params">&#123; formData,index &#125;</span>) =&gt;</span><br>          <span class="hljs-built_in">this</span>.request(&#123;<br>            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>            data: formData，<br>+           onProgress: <span class="hljs-built_in">this</span>.createProgressHandler(<span class="hljs-built_in">this</span>.data[index]),<br>          &#125;)<br>        );<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(requestList);<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.mergeRequest();<br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">handleUpload</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-built_in">this</span>.createFileChunk(<span class="hljs-built_in">this</span>.container.file);<br>      <span class="hljs-built_in">this</span>.data = fileChunkList.map(<span class="hljs-function">(<span class="hljs-params">&#123; file &#125;，index</span>) =&gt;</span> (&#123;<br>        chunk: file,<br>+       index,<br>        hash: <span class="hljs-built_in">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index<br>+       percentage:<span class="hljs-number">0</span><br>      &#125;));<br>      <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.uploadChunks();<br>    &#125;    <br>+   <span class="hljs-function"><span class="hljs-title">createProgressHandler</span>(<span class="hljs-params">item</span>)</span> &#123;<br>+      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>+        item.percentage = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>((e.loaded / e.total) * <span class="hljs-number">100</span>));<br>+      &#125;;<br>+   &#125;<br></code></pre></td></tr></table></figure>
<p>每个切片在上传时都会通过监听函数更新 data 数组对应元素的 percentage 属性，之后把将 data 数组放到视图中展示即可</p>
<h4 id="总进度条"><a href="#总进度条" class="headerlink" title="总进度条"></a>总进度条</h4><p>将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 的计算属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> computed: &#123;<br>      uploadPercentage() &#123;<br>         <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file || !<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">const</span> loaded = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>           .map(item =&gt; item.size * item.percentage)<br>           .reduce((acc, cur) =&gt; acc + cur);<br>         <span class="hljs-keyword">return</span> parseInt((loaded / <span class="hljs-keyword">this</span>.container.file.size).toFixed(<span class="hljs-number">2</span>));<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</p>
<p>前端使用 localStorage 记录已上传的切片 hash<br>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片<br>第一种是前端的解决方案，第二种是服务端，而前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</p>
<h4 id="生成-hash"><a href="#生成-hash" class="headerlink" title="生成 hash"></a>生成 hash</h4><p>无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用文件名 + 切片下标作为切片 hash，这样做文件名一旦修改就失去了效果，<strong>而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash</strong>，所以我们修改一下 hash 的生成规则</p>
<blockquote>
<p>webpack 的产物 contenthash 也是基于这个思路实现的</p>
</blockquote>
<p>这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值</p>
<p>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会<strong>引起 UI 的阻塞</strong>，导致页面假死状态，所以我们使用 web-worker 在 worker 线程计算 hash，这样用户仍可以在主界面正常的交互</p>
<p>由于实例化 web-worker 时，参数是一个 js 文件路径且不能跨域，所以我们单独创建一个 hash.js 文件放在 public 目录下，另外在 worker 中也是不允许访问 dom 的，但它提供了importScripts 函数用于导入外部脚本，通过它导入 spark-md5</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// /public/hash.js</span><br>​<br><span class="hljs-comment">// 导入脚本</span><br><span class="hljs-keyword">self</span>.importScripts(<span class="hljs-string">&quot;/spark-md5.min.js&quot;</span>);<br>​<br><span class="hljs-comment">// 生成文件 hash</span><br><span class="hljs-keyword">self</span>.onmessage = e =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; fileChunkList &#125; = e.data;<br>  <span class="hljs-keyword">const</span> spark = <span class="hljs-keyword">new</span> <span class="hljs-keyword">self</span>.SparkMD5.ArrayBuffer();<br>  <span class="hljs-keyword">let</span> percentage = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> loadNext = index =&gt; &#123;<br>    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();<br>    reader.readAsArrayBuffer(fileChunkList[index].file);<br>    reader.onload = e =&gt; &#123;<br>      count++;<br>      spark.append(e.target.result);<br>      <span class="hljs-keyword">if</span> (count === fileChunkList.length) &#123;<br>        <span class="hljs-keyword">self</span>.postMessage(&#123;<br>          percentage: <span class="hljs-number">100</span>,<br>          hash: spark.end()<br>        &#125;);<br>        <span class="hljs-keyword">self</span>.close();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        percentage += <span class="hljs-number">100</span> / fileChunkList.length;<br>        <span class="hljs-keyword">self</span>.postMessage(&#123;<br>          percentage<br>        &#125;);<br>        <span class="hljs-comment">// calculate recursively</span><br>        loadNext(count);<br>      &#125;<br>    &#125;;<br>  &#125;;<br>  loadNext(<span class="hljs-number">0</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在 worker 线程中，接受文件切片 fileChunkList，利用 fileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程</p>
<blockquote>
<p>spark-md5 文档中要求传入所有切片并算出 hash 值，不能直接将整个文件放入计算，否则即使不同文件也会有相同的 hash</p>
</blockquote>
<p>接着编写主线程与 worker 线程通讯的逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">+    <span class="hljs-comment">// 生成文件 hash（web-worker）</span><br>+    calculateHash(fileChunkList) &#123;<br>+      <span class="hljs-keyword">return</span> new Promise(resolve =&gt; &#123;<br>+        <span class="hljs-comment">// 添加 worker 属性</span><br>+        <span class="hljs-keyword">this</span>.container.worker = new Worker(<span class="hljs-string">&quot;/hash.js&quot;</span>);<br>+        <span class="hljs-keyword">this</span>.container.worker.postMessage(&#123; fileChunkList &#125;);<br>+        <span class="hljs-keyword">this</span>.container.worker.onmessage = e =&gt; &#123;<br>+          <span class="hljs-keyword">const</span> &#123; percentage, hash &#125; = e.<span class="hljs-keyword">data</span>;<br>+          <span class="hljs-keyword">this</span>.hashPercentage = percentage;<br>+          <span class="hljs-keyword">if</span> (hash) &#123;<br>+            resolve(hash);<br>+          &#125;<br>+        &#125;;<br>+      &#125;);<br>    &#125;,<br>    async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>+     <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;，index) =&gt; (&#123;<br>+       fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        chunk: file,<br>        hash: <span class="hljs-keyword">this</span>.container.file.name + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        percentage:<span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks();<span class="hljs-number">000</span><br>    &#125;   <br></code></pre></td></tr></table></figure>
<p>主线程使用 <strong>postMessage</strong> 给 worker 线程传入所有切片 fileChunkList，并监听 worker 线程发出的 postMessage 事件拿到文件 hash<br>加上显示计算 hash 的进度条，看起来像这样</p>
<p>至此前端需要将之前用文件名作为 hash 的地方改写为 worker 返回的 hash</p>
<p>服务端则使用固定前缀 + hash 作为切片文件夹名，hash + 下标作为切片名，hash + 扩展名作为文件名</p>
<h4 id="文件秒传"><a href="#文件秒传" class="headerlink" title="文件秒传"></a>文件秒传</h4><p>在实现断点续传前先简单介绍一下文件秒传</p>
<p>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功</p>
<p>文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">+    async verifyUpload(filename, fileHash) &#123;<br>+       <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">data</span> &#125; = await <span class="hljs-keyword">this</span>.request(&#123;<br>+         url: <span class="hljs-string">&quot;http://localhost:3000/verify&quot;</span>,<br>+         headers: &#123;<br>+           <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>+         &#125;,<br>+         <span class="hljs-keyword">data</span>: JSON.stringify(&#123;<br>+           filename,<br>+           fileHash<br>+         &#125;)<br>+       &#125;);<br>+       <span class="hljs-keyword">return</span> JSON.parse(<span class="hljs-keyword">data</span>);<br>+     &#125;,<br>   async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>+     <span class="hljs-keyword">const</span> &#123; shouldUpload &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+       <span class="hljs-keyword">this</span>.container.file.name,<br>+       <span class="hljs-keyword">this</span>.container.hash<br>+     );<br>+     <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>+       <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>+       <span class="hljs-keyword">return</span>;<br>+    &#125;<br>     <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file,<br>        percentage: <span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks();<br>    &#125;   <br></code></pre></td></tr></table></figure>
<p>秒传其实就是给用户看的障眼法，实质上根本没有上传</p>
<p>服务端的逻辑非常简单，新增一个验证接口，验证文件是否存在即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+ <span class="hljs-comment">// 提取后缀名</span><br>+ <span class="hljs-keyword">const</span> extractExt = <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span><br>+  filename.slice(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>), filename.length);<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>    req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      chunk += data;<br>    &#125;);<br>    req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>    &#125;);<br>  &#125;);<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/verify&quot;</span>) &#123;<br>+    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>+    <span class="hljs-keyword">const</span> &#123; fileHash, filename &#125; = data;<br>+    <span class="hljs-keyword">const</span> ext = extractExt(filename);<br>+    <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileHash&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>);<br>+    <span class="hljs-keyword">if</span> (fse.existsSync(filePath)) &#123;<br>+      res.end(<br>+        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+          shouldUpload: <span class="hljs-literal">false</span><br>+        &#125;)<br>+      );<br>+    &#125; <span class="hljs-keyword">else</span> &#123;<br>+      res.end(<br>+        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>+          shouldUpload: <span class="hljs-literal">true</span><br>+        &#125;)<br>+      );<br>+    &#125;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>

<h4 id="暂停上传"><a href="#暂停上传" class="headerlink" title="暂停上传"></a>暂停上传</h4><p>讲完了生成 hash 和文件秒传，回到断点续传</p>
<p>断点续传顾名思义即断点 + 续传，所以我们第一步先实现“断点”，也就是暂停上传</p>
<p>原理是使用 XMLHttpRequest 的 <strong>abort</strong> 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">request(&#123;<br>      url,<br>      method = <span class="hljs-string">&quot;post&quot;</span>,<br>      data,<br>      headers = &#123;&#125;,<br>      onProgress = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> e,<br>+     requestList<br>    &#125;) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>        xhr.upload.onprogress = onProgress;<br>        xhr.open(method, url);<br>        <span class="hljs-built_in">Object</span>.keys(headers).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span><br>          xhr.setRequestHeader(key, headers[key])<br>        );<br>        xhr.send(data);<br>        xhr.onload = <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>+          <span class="hljs-comment">// 将请求成功的 xhr 从列表中删除</span><br>+          <span class="hljs-keyword">if</span> (requestList) &#123;<br>+            <span class="hljs-keyword">const</span> xhrIndex = requestList.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === xhr);<br>+            requestList.splice(xhrIndex, <span class="hljs-number">1</span>);<br>+          &#125;<br>          resolve(&#123;<br>            data: e.target.response<br>          &#125;);<br>        &#125;;<br>+        <span class="hljs-comment">// 暴露当前 xhr 给外部</span><br>+        requestList?.push(xhr);<br>      &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure>
<p>这样在上传切片时传入 requestList 数组作为参数，request 方法就会将所有的 xhr 保存在数组中了</p>
<p>每当一个切片上传成功时，将对应的 xhr 从 requestList 中删除，所以 requestList 中只保存<strong>正在上传切片的 xhr</strong></p>
<p>之后新建一个暂停按钮，当点击按钮时，调用保存在 requestList 中 xhr 的 abort 方法，即取消并清空所有正在上传的切片</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">handlePause</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.requestList.forEach(<span class="hljs-function"><span class="hljs-params">xhr</span> =&gt;</span> xhr?.abort());<br>    <span class="hljs-built_in">this</span>.requestList = [];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>点击暂停按钮可以看到 xhr 都被取消了</p>
<h4 id="恢复上传"><a href="#恢复上传" class="headerlink" title="恢复上传"></a>恢复上传</h4><p>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</p>
<p>由于当文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</p>
<p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p>
<ol>
<li>服务端已存在该文件，不需要再次上传</li>
<li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把<strong>已上传</strong>的文件切片返回给前端<br>所以我们改造一下之前文件秒传的服务端验证接口<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> extractExt = <span class="hljs-function"><span class="hljs-params">filename</span> =&gt;</span><br>  filename.slice(filename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>), filename.length);<br><span class="hljs-keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>);<br>​<br><span class="hljs-keyword">const</span> resolvePost = <span class="hljs-function"><span class="hljs-params">req</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> chunk = <span class="hljs-string">&quot;&quot;</span>;<br>    req.on(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      chunk += data;<br>    &#125;);<br>    req.on(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      resolve(<span class="hljs-built_in">JSON</span>.parse(chunk));<br>    &#125;);<br>  &#125;);<br>  <br>+ <span class="hljs-comment">// 返回已上传的所有切片名</span><br>+ <span class="hljs-keyword">const</span> createUploadedList = <span class="hljs-keyword">async</span> fileHash =&gt;<br>+   fse.existsSync(path.resolve(UPLOAD_DIR, fileHash))<br>+    ? <span class="hljs-keyword">await</span> fse.readdir(path.resolve(UPLOAD_DIR, fileHash))<br>+    : [];<br>​<br>server.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (req.url === <span class="hljs-string">&quot;/verify&quot;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resolvePost(req);<br>    <span class="hljs-keyword">const</span> &#123; fileHash, filename &#125; = data;<br>    <span class="hljs-keyword">const</span> ext = extractExt(filename);<br>    <span class="hljs-keyword">const</span> filePath = path.resolve(UPLOAD_DIR, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileHash&#125;</span><span class="hljs-subst">$&#123;ext&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (fse.existsSync(filePath)) &#123;<br>      res.end(<br>        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>          shouldUpload: <span class="hljs-literal">false</span><br>        &#125;)<br>      );<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res.end(<br>        <span class="hljs-built_in">JSON</span>.stringify(&#123;<br>          shouldUpload: <span class="hljs-literal">true</span>，<br>+         uploadedList: <span class="hljs-keyword">await</span> createUploadedList(fileHash)<br>        &#125;)<br>      );<br>    &#125;<br>  &#125;<br>&#125;);<br>​<br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>));<br></code></pre></td></tr></table></figure>
接着回到前端，前端有两个地方需要调用验证的接口</li>
</ol>
<p>点击上传时，检查是否需要上传和已上传的切片<br>点击暂停后的恢复上传，返回已上传的切片<br>新增恢复按钮并改造原来上传切片的逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;template&gt;<br>  &lt;div id=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>      &lt;input<br>        type=<span class="hljs-string">&quot;file&quot;</span><br>        <span class="hljs-meta">@change</span>=<span class="hljs-string">&quot;handleFileChange&quot;</span><br>      /&gt;<br>       &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handleUpload&quot;</span>&gt;upload&lt;/el-button&gt;<br>       &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handlePause&quot;</span> v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isPaused&quot;</span>&gt;pause&lt;/el-button&gt;<br>+      &lt;el-button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;handleResume&quot;</span> v-<span class="hljs-keyword">else</span>&gt;resume&lt;/el-button&gt;<br>      <span class="hljs-comment">//...</span><br>    &lt;/div&gt;<br>&lt;/template&gt;<br>​<br>+   async handleResume() &#123;<br>+      <span class="hljs-keyword">const</span> &#123; uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+        <span class="hljs-keyword">this</span>.container.file.name,<br>+        <span class="hljs-keyword">this</span>.container.hash<br>+      );<br>+      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br>    async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>+     <span class="hljs-keyword">const</span> &#123; shouldUpload, uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>+       <span class="hljs-keyword">this</span>.container.file.name,<br>+       <span class="hljs-keyword">this</span>.container.hash<br>+     );<br>+     <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>+       <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>+       <span class="hljs-keyword">return</span>;<br>+     &#125;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file，<br>        percentage: <span class="hljs-number">0</span><br>      &#125;));<br>+      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br>    <span class="hljs-comment">// 上传切片，同时过滤已上传的切片</span><br>+   async uploadChunks(uploadedList = []) &#123;<br>      <span class="hljs-keyword">const</span> requestList = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>+       .filter((&#123; hash &#125;) =&gt; !uploadedList.includes(hash))<br>        .map((&#123; chunk, hash, index &#125;) =&gt; &#123;<br>          <span class="hljs-keyword">const</span> formData = new FormData();<br>          formData.append(<span class="hljs-string">&quot;chunk&quot;</span>, chunk);<br>          formData.append(<span class="hljs-string">&quot;hash&quot;</span>, hash);<br>          formData.append(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-keyword">this</span>.container.file.name);<br>          formData.append(<span class="hljs-string">&quot;fileHash&quot;</span>, <span class="hljs-keyword">this</span>.container.hash);<br>          <span class="hljs-keyword">return</span> &#123; formData, index &#125;;<br>        &#125;)<br>        .map((&#123; formData, index &#125;) =&gt;<br>          <span class="hljs-keyword">this</span>.request(&#123;<br>            url: <span class="hljs-string">&quot;http://localhost:3000&quot;</span>,<br>            <span class="hljs-keyword">data</span>: formData,<br>            onProgress: <span class="hljs-keyword">this</span>.createProgressHandler(<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>[index]),<br>            requestList: <span class="hljs-keyword">this</span>.requestList<br>          &#125;)<br>        );<br>      await Promise.all(requestList);<br>+     <span class="hljs-comment">// 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片</span><br>+     <span class="hljs-keyword">if</span> (uploadedList.length + requestList.length === <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) &#123;<br>         await <span class="hljs-keyword">this</span>.mergeRequest();<br>+     &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里给原来上传切片的函数新增 uploadedList 参数，即上图中服务端返回的切片名列表，通过 filter 过滤掉已上传的切片，并且由于新增了已上传的部分，所以之前合并接口的触发条件做了一些改动</p>
<p>到这里断点续传的功能基本完成了</p>
<h4 id="进度条改进"><a href="#进度条改进" class="headerlink" title="进度条改进"></a>进度条改进</h4><p>虽然实现了断点续传，但还需要修改一下进度条的显示规则，否则在暂停上传/接收到已上传切片时的进度条会出现偏差</p>
<p>单个切片进度条<br>由于在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">   async handleUpload() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-keyword">const</span> fileChunkList = <span class="hljs-keyword">this</span>.createFileChunk(<span class="hljs-keyword">this</span>.container.file);<br>      <span class="hljs-keyword">this</span>.container.hash = await <span class="hljs-keyword">this</span>.calculateHash(fileChunkList);<br>      <span class="hljs-keyword">const</span> &#123; shouldUpload, uploadedList &#125; = await <span class="hljs-keyword">this</span>.verifyUpload(<br>        <span class="hljs-keyword">this</span>.container.file.name,<br>        <span class="hljs-keyword">this</span>.container.hash<br>      );<br>      <span class="hljs-keyword">if</span> (!shouldUpload) &#123;<br>        <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">&quot;skip upload：file upload success&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span> = fileChunkList.map((&#123; file &#125;, index) =&gt; (&#123;<br>        fileHash: <span class="hljs-keyword">this</span>.container.hash,<br>        index,<br>        hash: <span class="hljs-keyword">this</span>.container.hash + <span class="hljs-string">&quot;-&quot;</span> + index,<br>        chunk: file,<br>+       percentage: uploadedList.includes(index) ? <span class="hljs-number">100</span> : <span class="hljs-number">0</span><br>      &#125;));<br>      await <span class="hljs-keyword">this</span>.uploadChunks(uploadedList);<br>    &#125;,<br></code></pre></td></tr></table></figure>
<p>uploadedList 会返回已上传的切片，在遍历所有切片时判断当前切片是否在已上传列表里即可</p>
<h4 id="总进度条-1"><a href="#总进度条-1" class="headerlink" title="总进度条"></a>总进度条</h4><p>之前说到总进度条是一个计算属性，根据所有切片的上传进度计算而来，这就遇到了一个问题</p>
<p>点击暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有倒退的现象</p>
<p>当点击恢复时，由于重新创建了 xhr 导致切片进度清零，所以总进度条就会倒退</p>
<p>解决方案是创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加，然后给用户展示这个假的进度条</p>
<p>这里我们使用 Vue 的监听属性</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-keyword">data</span>: () =&gt; (&#123;<br>+    fakeUploadPercentage: <span class="hljs-number">0</span><br>  &#125;),<br>  computed: &#123;<br>    uploadPercentage() &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.container.file || !<span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>.length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">const</span> loaded = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span><br>        .map(item =&gt; item.size * item.percentage)<br>        .reduce((acc, cur) =&gt; acc + cur);<br>      <span class="hljs-keyword">return</span> parseInt((loaded / <span class="hljs-keyword">this</span>.container.file.size).toFixed(<span class="hljs-number">2</span>));<br>    &#125;<br>  &#125;,  <br>  watch: &#123;<br>+    uploadPercentage(now) &#123;<br>+      <span class="hljs-keyword">if</span> (now &gt; <span class="hljs-keyword">this</span>.fakeUploadPercentage) &#123;<br>+        <span class="hljs-keyword">this</span>.fakeUploadPercentage = now;<br>+      &#125;<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure>
<p>当 uploadPercentage 即真的文件进度条增加时，fakeUploadPercentage 也增加，一旦文件进度条后退，假的进度条只需停止即可</p>
<p>至此一个大文件上传 + 断点续传的解决方案就完成了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大文件上传</p>
<ol>
<li>前端上传大文件时使用 Blob.prototype.slice 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li>
<li>服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件</li>
<li>原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听</li>
<li>使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</li>
</ol>
<p>断点续传</p>
<ol>
<li>使用 spark-md5 根据文件内容算出文件 hash</li>
<li>通过 hash 可以判断服务端是否已经上传该文件，从而直接提示用户上传成功（秒传）</li>
<li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传</li>
<li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<h3 id="大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？"><a href="#大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？" class="headerlink" title="大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？"></a>大文件上传，使用切片上传形式，支持上传、暂停、续传你怎么实现的？</h3></li>
</ol>
<h4 id="1-发现问题"><a href="#1-发现问题" class="headerlink" title="1. 发现问题"></a>1. 发现问题</h4><p>如果前端不使用大文件上传，可能会导致以下问题：</p>
<ol>
<li><p><strong>用户体验下降</strong>：如果用户需要上传较大的文件，而前端没有实现大文件上传功能，那么用户上传文件的速度将受到较大的限制，<strong>可能需要等待较长的时间</strong>，这将导致用户体验下降。</p>
</li>
<li><p><strong>网络带宽消耗过大</strong>：如果前端没有实现大文件上传功能，那么上传一个大文件将会占用较多的网络带宽，这可能会影响其他用户的网络使用，尤其是在网络资源有限的情况下。</p>
</li>
<li><p><strong>上传失败的风险增加</strong>：如果前端没有实现大文件上传功能，那么上传一个大文件的失败概率将会增加。这是因为在上传较大的文件时，<strong>一旦上传失败，需要重新上传整个文件</strong>，这将会浪费大量时间和网络资源。</p>
</li>
</ol>
<p>因此，为了提高用户体验，减少网络资源占用和降低上传失败的风险，前端需要实现大文件上传功能。</p>
<h4 id="大文件上传-原理-gt-实现思路"><a href="#大文件上传-原理-gt-实现思路" class="headerlink" title="大文件上传(原理 -&gt;实现思路)"></a>大文件上传(原理 -&gt;实现思路)</h4><ol>
<li>前端上传大文件时使用 <strong>Blob.prototype.slice</strong> 将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片</li>
</ol>
<p>预先定义好单个切片大小，将文件切分为一个个切片，然后<strong>借助 http 的可并发性，同时上传多个切片</strong>。这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间.</p>
<p>—(HTTP 的可并发性指的是在同一时间内可以同时处理多个 HTTP 请求。HTTP 是一种无状态的协议，每个请求之间都是相互独立的。因此，HTTP 协议天生就具备可并发性，允许客户端在同一时间内向服务器发起多个请求，而服务器也可以同时处理多个请求。)</p>
<p>另外由于是并发，传输到服务端的顺序可能会发生变化，因此我们<strong>还需要给每个切片记录顺序</strong></p>
<ul>
<li>详细<br>（当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过文件大小控制，<strong>这里设置 10MB，也就是说一个 100 MB 的文件会被分成 10 个 10MB 的切片</strong><br>createFileChunk 内使用 while 循环和 slice 方法将切片放入 <strong>fileChunkList</strong> 数组中返回</li>
</ul>
<p>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用<strong>文件名 + 下标</strong>，这样<strong>后端可以知道当前切片是第几个切片，用于之后的合并切片</strong></p>
<p>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 formData 中，再调用上一步的 request 函数返回一个 proimise，最后<strong>调用 Promise.all 并发上传所有的切片</strong>发送合并请求<br>2. 服务端接收切片并存储，收到合并请求后使用流将切片合并到最终文件<br>3. 原生 XMLHttpRequest 的 upload.onprogress 对切片上传进度的监听<br>4. 使用 Vue 计算属性根据每个切片的进度算出整个文件的上传进度</p>
<h4 id="断点续传-1"><a href="#断点续传-1" class="headerlink" title="断点续传"></a>断点续传</h4><ul>
<li>原理<br>断点续传的<strong>原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，有两种方案实现记忆的功能</strong></li>
</ul>
<p>前端使用 localStorage 记录已上传的切片 hash<br>服务端保存已上传的切片 hash，前端每次上传前向服务端获取已上传的切片<br>第一种是前端的解决方案，第二种是服务端，而<strong>前端方案有一个缺陷，如果换了个浏览器就失去了记忆的效果，所以这里选后者</strong></p>
<ol>
<li>使用 spark-md5 根据文件内容算出文件 hash<br>生成 hash<br>无论是前端还是服务端，都必须要生成文件和切片的 hash，之前我们使用<strong>文件名 + 切片下标作为切片 hash</strong>，这样做文件名<strong>一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash</strong>，所以我们修改一下 hash 的生成规则<blockquote>
<p>webpack 的产物 contenthash 也是基于这个思路实现的</p>
</blockquote>
</li>
</ol>
<p>这里用到另一个库 spark-md5，它可以根据文件内容计算出文件的 hash 值<br>另外考虑到如果上传一个超大文件，读取文件内容计算 hash 是非常耗费时间的，并且会引起 UI 的阻塞，导致页面假死状态，所以我们使用 <strong>web-worker 在 worker 线程计算 hash</strong>，这样用户仍可以在主界面正常的交互</p>
<h4 id="文件秒传-1"><a href="#文件秒传-1" class="headerlink" title="文件秒传"></a>文件秒传</h4><ol start="2">
<li>通过<strong>hash 可以判断服务端是否已经上传该文件</strong>，从而直接提示用户上传成功（秒传）<br>所谓的文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功</li>
</ol>
<p><strong>文件秒传需要依赖上一步生成的 hash，即在上传前，先计算出文件 hash</strong>，并把 hash 发送给服务端进行验证，由于 hash 的唯一性，所以一旦服务端能找到 hash 相同的文件，则直接返回上传成功的信息即可</p>
<p>秒传其实就是给用户看的障眼法，实质上根本没有上传<br>服务端的逻辑非常简单，<strong>新增一个验证接口，验证文件是否存在即可</strong></p>
<h4 id="暂停上传-1"><a href="#暂停上传-1" class="headerlink" title="暂停上传"></a>暂停上传</h4><ol start="3">
<li>通过 XMLHttpRequest 的 abort 方法暂停切片的上传<br>讲完了生成 hash 和文件秒传，回到断点续传</li>
</ol>
<p>断点续传顾名思义即<strong>断点 + 续传</strong>，所以我们第一步先实现“断点”，也就是暂停上传</p>
<p>原理是使用 XMLHttpRequest 的 <strong>abor</strong>t 方法，可以取消一个 xhr 请求的发送，为此我们需要将上传每个切片的 xhr 对象保存起来，我们再改造一下 request 方法</p>
<h4 id="恢复上传-1"><a href="#恢复上传-1" class="headerlink" title="恢复上传"></a>恢复上传</h4><ol start="4">
<li>上传前服务端返回已经上传的切片名，前端跳过这些切片的上传<br>之前在介绍断点续传的时提到使用第二种服务端存储的方式实现续传</li>
</ol>
<p>由于当文件切片上传后，<strong>服务端会建立一个文件夹存储所有上传的切片，所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果</strong></p>
<p>而这个接口可以和之前秒传的验证接口合并，前端每次上传前发送一个验证的请求，返回两种结果</p>
<ol>
<li>服务端已存在该文件，不需要再次上传</li>
<li>服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把已上传的文件切片返回给前端<br>所以我们改造一下之前文件秒传的服务端验证接口</li>
</ol>
<h4 id="大文件上传-1"><a href="#大文件上传-1" class="headerlink" title="大文件上传"></a>大文件上传</h4><ol>
<li>将大文件转换成二进制流的格式</li>
<li>利用流可以切割的属性，将二进制流切割成多份</li>
<li>组装和分割块同等数量的请求块，并行或串行的形式发出请求</li>
<li>待我们监听到所有请求都成功发出去以后，再给服务端发出一个合并的信号</li>
</ol>
<h4 id="断点续传-2"><a href="#断点续传-2" class="headerlink" title="断点续传"></a>断点续传</h4><ol>
<li>为每一个文件切割块添加不同的标识hash</li>
<li>当上传成功的之后，服务器记录上传成功的标识 </li>
<li>下次继续上传的时候从服务端获取已经上传的文件分片hash 下次上传的时候不需要上传这个分片</li>
<li>当我们暂停或者发送失败后，可以重新发送没有上传成功的切割文件</li>
<li>最后全部上传成功还是给服务端发出一个合并的信号–服务器可以清除所有的分片</li>
<li>这里存在服务器临时存储分片文件过多占用磁盘过大的问题–所以可以设置过期时间定期清除过期的分片 避免资源浪费</li>
</ol>
<h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904046436843527#heading-20">字节跳动面试官：请你实现一个大文件上传和断点续传</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/">项目优化</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
                    
                      <a class="hover-with-bg" href="/tags/JS/">JS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%AE%9E%E7%8E%B0select%E4%B8%8B%E6%8B%89%E6%90%9C%E7%B4%A2%EF%BC%8C%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">实现select下拉搜索，无限滚动(项目)</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/28/%5B%E9%A1%B9%E7%9B%AE%5D%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/">
                        <span class="hidden-mobile">前端性能优化建议(项目)</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
